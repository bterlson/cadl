{
  "directories": [
    {
      "name": "./src/Generated/Models",
      "files": [
        {
          "name": "ThingRequiredLiteralString.cs",
          "typeDeclaration": {
            "name": "ThingRequiredLiteralString",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The Thing_requiredLiteralString. \u003C/summary\u003E\n    public readonly partial struct ThingRequiredLiteralString : IEquatable\u003CThingRequiredLiteralString\u003E\n    {\n        private readonly string _value;\n        /// \u003Csummary\u003E accept. \u003C/summary\u003E\n        private const string AcceptValue = \u0022accept\u0022;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022ThingRequiredLiteralString\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022value\u0022/\u003E is null. \u003C/exception\u003E\n        public ThingRequiredLiteralString(string value)\n        {\n            Argument.AssertNotNull(value, nameof(value));\n\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E accept. \u003C/summary\u003E\n        public static ThingRequiredLiteralString Accept { get; } = new ThingRequiredLiteralString(AcceptValue);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022ThingRequiredLiteralString\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(ThingRequiredLiteralString left, ThingRequiredLiteralString right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022ThingRequiredLiteralString\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(ThingRequiredLiteralString left, ThingRequiredLiteralString right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022ThingRequiredLiteralString\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator ThingRequiredLiteralString(string value) =\u003E new ThingRequiredLiteralString(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [EditorBrowsableAttribute(EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is ThingRequiredLiteralString other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(ThingRequiredLiteralString other) =\u003E string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E (_value != null) ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "ThingRequiredLiteralInt.cs",
          "typeDeclaration": {
            "name": "ThingRequiredLiteralInt",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The Thing_requiredLiteralInt. \u003C/summary\u003E\n    public readonly partial struct ThingRequiredLiteralInt : IEquatable\u003CThingRequiredLiteralInt\u003E\n    {\n        private readonly int _value;\n        /// \u003Csummary\u003E 123. \u003C/summary\u003E\n        private const int _123Value = 123;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022ThingRequiredLiteralInt\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public ThingRequiredLiteralInt(int value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E 123. \u003C/summary\u003E\n        public static ThingRequiredLiteralInt _123 { get; } = new ThingRequiredLiteralInt(_123Value);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022ThingRequiredLiteralInt\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(ThingRequiredLiteralInt left, ThingRequiredLiteralInt right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022ThingRequiredLiteralInt\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(ThingRequiredLiteralInt left, ThingRequiredLiteralInt right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022ThingRequiredLiteralInt\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator ThingRequiredLiteralInt(int value) =\u003E new ThingRequiredLiteralInt(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [EditorBrowsableAttribute(EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is ThingRequiredLiteralInt other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(ThingRequiredLiteralInt other) =\u003E int.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "ThingRequiredLiteralInt.Serialization.cs",
          "typeDeclaration": {
            "name": "ThingRequiredLiteralInt",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public readonly partial struct ThingRequiredLiteralInt\n    {\n        internal int ToSerialInt32() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "ThingRequiredLiteralFloat.cs",
          "typeDeclaration": {
            "name": "ThingRequiredLiteralFloat",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The Thing_requiredLiteralFloat. \u003C/summary\u003E\n    public readonly partial struct ThingRequiredLiteralFloat : IEquatable\u003CThingRequiredLiteralFloat\u003E\n    {\n        private readonly float _value;\n        /// \u003Csummary\u003E 1.23. \u003C/summary\u003E\n        private const float _123Value = 1.23F;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022ThingRequiredLiteralFloat\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public ThingRequiredLiteralFloat(float value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E 1.23. \u003C/summary\u003E\n        public static ThingRequiredLiteralFloat _123 { get; } = new ThingRequiredLiteralFloat(_123Value);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022ThingRequiredLiteralFloat\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(ThingRequiredLiteralFloat left, ThingRequiredLiteralFloat right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022ThingRequiredLiteralFloat\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(ThingRequiredLiteralFloat left, ThingRequiredLiteralFloat right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022ThingRequiredLiteralFloat\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator ThingRequiredLiteralFloat(float value) =\u003E new ThingRequiredLiteralFloat(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [EditorBrowsableAttribute(EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is ThingRequiredLiteralFloat other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(ThingRequiredLiteralFloat other) =\u003E float.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "ThingRequiredLiteralFloat.Serialization.cs",
          "typeDeclaration": {
            "name": "ThingRequiredLiteralFloat",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public readonly partial struct ThingRequiredLiteralFloat\n    {\n        internal float ToSerialSingle() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "ThingOptionalLiteralString.cs",
          "typeDeclaration": {
            "name": "ThingOptionalLiteralString",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The Thing_optionalLiteralString. \u003C/summary\u003E\n    public readonly partial struct ThingOptionalLiteralString : IEquatable\u003CThingOptionalLiteralString\u003E\n    {\n        private readonly string _value;\n        /// \u003Csummary\u003E reject. \u003C/summary\u003E\n        private const string RejectValue = \u0022reject\u0022;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022ThingOptionalLiteralString\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022value\u0022/\u003E is null. \u003C/exception\u003E\n        public ThingOptionalLiteralString(string value)\n        {\n            Argument.AssertNotNull(value, nameof(value));\n\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E reject. \u003C/summary\u003E\n        public static ThingOptionalLiteralString Reject { get; } = new ThingOptionalLiteralString(RejectValue);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022ThingOptionalLiteralString\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(ThingOptionalLiteralString left, ThingOptionalLiteralString right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022ThingOptionalLiteralString\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(ThingOptionalLiteralString left, ThingOptionalLiteralString right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022ThingOptionalLiteralString\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator ThingOptionalLiteralString(string value) =\u003E new ThingOptionalLiteralString(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [EditorBrowsableAttribute(EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is ThingOptionalLiteralString other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(ThingOptionalLiteralString other) =\u003E string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E (_value != null) ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "ThingOptionalLiteralInt.cs",
          "typeDeclaration": {
            "name": "ThingOptionalLiteralInt",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The Thing_optionalLiteralInt. \u003C/summary\u003E\n    public readonly partial struct ThingOptionalLiteralInt : IEquatable\u003CThingOptionalLiteralInt\u003E\n    {\n        private readonly int _value;\n        /// \u003Csummary\u003E 456. \u003C/summary\u003E\n        private const int _456Value = 456;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022ThingOptionalLiteralInt\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public ThingOptionalLiteralInt(int value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E 456. \u003C/summary\u003E\n        public static ThingOptionalLiteralInt _456 { get; } = new ThingOptionalLiteralInt(_456Value);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022ThingOptionalLiteralInt\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(ThingOptionalLiteralInt left, ThingOptionalLiteralInt right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022ThingOptionalLiteralInt\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(ThingOptionalLiteralInt left, ThingOptionalLiteralInt right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022ThingOptionalLiteralInt\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator ThingOptionalLiteralInt(int value) =\u003E new ThingOptionalLiteralInt(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [EditorBrowsableAttribute(EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is ThingOptionalLiteralInt other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(ThingOptionalLiteralInt other) =\u003E int.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "ThingOptionalLiteralInt.Serialization.cs",
          "typeDeclaration": {
            "name": "ThingOptionalLiteralInt",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public readonly partial struct ThingOptionalLiteralInt\n    {\n        internal int ToSerialInt32() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "ThingOptionalLiteralFloat.cs",
          "typeDeclaration": {
            "name": "ThingOptionalLiteralFloat",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The Thing_optionalLiteralFloat. \u003C/summary\u003E\n    public readonly partial struct ThingOptionalLiteralFloat : IEquatable\u003CThingOptionalLiteralFloat\u003E\n    {\n        private readonly float _value;\n        /// \u003Csummary\u003E 4.56. \u003C/summary\u003E\n        private const float _456Value = 4.56F;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022ThingOptionalLiteralFloat\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public ThingOptionalLiteralFloat(float value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E 4.56. \u003C/summary\u003E\n        public static ThingOptionalLiteralFloat _456 { get; } = new ThingOptionalLiteralFloat(_456Value);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022ThingOptionalLiteralFloat\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(ThingOptionalLiteralFloat left, ThingOptionalLiteralFloat right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022ThingOptionalLiteralFloat\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(ThingOptionalLiteralFloat left, ThingOptionalLiteralFloat right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022ThingOptionalLiteralFloat\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator ThingOptionalLiteralFloat(float value) =\u003E new ThingOptionalLiteralFloat(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [EditorBrowsableAttribute(EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is ThingOptionalLiteralFloat other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(ThingOptionalLiteralFloat other) =\u003E float.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "ThingOptionalLiteralFloat.Serialization.cs",
          "typeDeclaration": {
            "name": "ThingOptionalLiteralFloat",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public readonly partial struct ThingOptionalLiteralFloat\n    {\n        internal float ToSerialSingle() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "StringFixedEnum.cs",
          "typeDeclaration": {
            "name": "StringFixedEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E Simple enum. \u003C/summary\u003E\n    public enum StringFixedEnum\n    {\n        /// \u003Csummary\u003E One. \u003C/summary\u003E\n        One,\n        /// \u003Csummary\u003E Two. \u003C/summary\u003E\n        Two,\n        /// \u003Csummary\u003E Four. \u003C/summary\u003E\n        Four\n    }\n}\n"
          }
        },
        {
          "name": "StringFixedEnum.Serialization.cs",
          "typeDeclaration": {
            "name": "StringFixedEnumExtensions",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    internal static partial class StringFixedEnumExtensions\n    {\n        public static string ToSerialString(this StringFixedEnum value) =\u003E value switch\n        {\n            StringFixedEnum.One =\u003E \u00221\u0022,\n            StringFixedEnum.Two =\u003E \u00222\u0022,\n            StringFixedEnum.Four =\u003E \u00224\u0022,\n            _ =\u003E throw new ArgumentOutOfRangeException(nameof(value), value, \u0022Unknown StringFixedEnum value.\u0022)\n        };\n\n        public static StringFixedEnum ToStringFixedEnum(this string value)\n        {\n            if (StringComparer.OrdinalIgnoreCase.Equals(value, \u00221\u0022))\n            {\n                return StringFixedEnum.One;\n            }\n            if (StringComparer.OrdinalIgnoreCase.Equals(value, \u00222\u0022))\n            {\n                return StringFixedEnum.Two;\n            }\n            if (StringComparer.OrdinalIgnoreCase.Equals(value, \u00224\u0022))\n            {\n                return StringFixedEnum.Four;\n            }\n            throw new ArgumentOutOfRangeException(nameof(value), value, \u0022Unknown StringFixedEnum value.\u0022);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "StringExtensibleEnum.cs",
          "typeDeclaration": {
            "name": "StringExtensibleEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E Extensible enum. \u003C/summary\u003E\n    public readonly partial struct StringExtensibleEnum : IEquatable\u003CStringExtensibleEnum\u003E\n    {\n        private readonly string _value;\n        private const string OneValue = \u00221\u0022;\n        private const string TwoValue = \u00222\u0022;\n        private const string FourValue = \u00224\u0022;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022StringExtensibleEnum\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022value\u0022/\u003E is null. \u003C/exception\u003E\n        public StringExtensibleEnum(string value)\n        {\n            Argument.AssertNotNull(value, nameof(value));\n\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E Gets the One. \u003C/summary\u003E\n        public static StringExtensibleEnum One { get; } = new StringExtensibleEnum(OneValue);\n\n        /// \u003Csummary\u003E Gets the Two. \u003C/summary\u003E\n        public static StringExtensibleEnum Two { get; } = new StringExtensibleEnum(TwoValue);\n\n        /// \u003Csummary\u003E Gets the Four. \u003C/summary\u003E\n        public static StringExtensibleEnum Four { get; } = new StringExtensibleEnum(FourValue);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022StringExtensibleEnum\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(StringExtensibleEnum left, StringExtensibleEnum right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022StringExtensibleEnum\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(StringExtensibleEnum left, StringExtensibleEnum right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022StringExtensibleEnum\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator StringExtensibleEnum(string value) =\u003E new StringExtensibleEnum(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [EditorBrowsableAttribute(EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is StringExtensibleEnum other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(StringExtensibleEnum other) =\u003E string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E (_value != null) ? StringComparer.InvariantCultureIgnoreCase.GetHashCode(_value) : 0;\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "IntExtensibleEnum.cs",
          "typeDeclaration": {
            "name": "IntExtensibleEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E Int based extensible enum. \u003C/summary\u003E\n    public readonly partial struct IntExtensibleEnum : IEquatable\u003CIntExtensibleEnum\u003E\n    {\n        private readonly int _value;\n        private const int OneValue = 1;\n        private const int TwoValue = 2;\n        private const int FourValue = 4;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022IntExtensibleEnum\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public IntExtensibleEnum(int value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E Gets the One. \u003C/summary\u003E\n        public static IntExtensibleEnum One { get; } = new IntExtensibleEnum(OneValue);\n\n        /// \u003Csummary\u003E Gets the Two. \u003C/summary\u003E\n        public static IntExtensibleEnum Two { get; } = new IntExtensibleEnum(TwoValue);\n\n        /// \u003Csummary\u003E Gets the Four. \u003C/summary\u003E\n        public static IntExtensibleEnum Four { get; } = new IntExtensibleEnum(FourValue);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022IntExtensibleEnum\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(IntExtensibleEnum left, IntExtensibleEnum right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022IntExtensibleEnum\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(IntExtensibleEnum left, IntExtensibleEnum right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022IntExtensibleEnum\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator IntExtensibleEnum(int value) =\u003E new IntExtensibleEnum(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [EditorBrowsableAttribute(EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is IntExtensibleEnum other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(IntExtensibleEnum other) =\u003E int.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "IntExtensibleEnum.Serialization.cs",
          "typeDeclaration": {
            "name": "IntExtensibleEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public readonly partial struct IntExtensibleEnum\n    {\n        internal int ToSerialInt32() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "FloatExtensibleEnum.cs",
          "typeDeclaration": {
            "name": "FloatExtensibleEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E Float based extensible enum. \u003C/summary\u003E\n    public readonly partial struct FloatExtensibleEnum : IEquatable\u003CFloatExtensibleEnum\u003E\n    {\n        private readonly float _value;\n        private const float OneDotOneValue = 1.1F;\n        private const float TwoDotTwoValue = 2.2F;\n        private const float FourDotFourValue = 4.4F;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022FloatExtensibleEnum\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public FloatExtensibleEnum(float value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E Gets the OneDotOne. \u003C/summary\u003E\n        public static FloatExtensibleEnum OneDotOne { get; } = new FloatExtensibleEnum(OneDotOneValue);\n\n        /// \u003Csummary\u003E Gets the TwoDotTwo. \u003C/summary\u003E\n        public static FloatExtensibleEnum TwoDotTwo { get; } = new FloatExtensibleEnum(TwoDotTwoValue);\n\n        /// \u003Csummary\u003E Gets the FourDotFour. \u003C/summary\u003E\n        public static FloatExtensibleEnum FourDotFour { get; } = new FloatExtensibleEnum(FourDotFourValue);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022FloatExtensibleEnum\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(FloatExtensibleEnum left, FloatExtensibleEnum right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022FloatExtensibleEnum\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(FloatExtensibleEnum left, FloatExtensibleEnum right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022FloatExtensibleEnum\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator FloatExtensibleEnum(float value) =\u003E new FloatExtensibleEnum(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [EditorBrowsableAttribute(EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is FloatExtensibleEnum other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(FloatExtensibleEnum other) =\u003E float.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "FloatExtensibleEnum.Serialization.cs",
          "typeDeclaration": {
            "name": "FloatExtensibleEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public readonly partial struct FloatExtensibleEnum\n    {\n        internal float ToSerialSingle() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "FloatExtensibleEnumWithIntValue.cs",
          "typeDeclaration": {
            "name": "FloatExtensibleEnumWithIntValue",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ComponentModel;\nusing System.Globalization;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E float fixed enum. \u003C/summary\u003E\n    public readonly partial struct FloatExtensibleEnumWithIntValue : IEquatable\u003CFloatExtensibleEnumWithIntValue\u003E\n    {\n        private readonly float _value;\n        private const float OneValue = 1F;\n        private const float TwoValue = 2F;\n        private const float FourValue = 4F;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022FloatExtensibleEnumWithIntValue\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public FloatExtensibleEnumWithIntValue(float value)\n        {\n            _value = value;\n        }\n\n        /// \u003Csummary\u003E Gets the One. \u003C/summary\u003E\n        public static FloatExtensibleEnumWithIntValue One { get; } = new FloatExtensibleEnumWithIntValue(OneValue);\n\n        /// \u003Csummary\u003E Gets the Two. \u003C/summary\u003E\n        public static FloatExtensibleEnumWithIntValue Two { get; } = new FloatExtensibleEnumWithIntValue(TwoValue);\n\n        /// \u003Csummary\u003E Gets the Four. \u003C/summary\u003E\n        public static FloatExtensibleEnumWithIntValue Four { get; } = new FloatExtensibleEnumWithIntValue(FourValue);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022FloatExtensibleEnumWithIntValue\u0022/\u003E values are the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator ==(FloatExtensibleEnumWithIntValue left, FloatExtensibleEnumWithIntValue right) =\u003E left.Equals(right);\n\n        /// \u003Csummary\u003E Determines if two \u003Csee cref=\u0022FloatExtensibleEnumWithIntValue\u0022/\u003E values are not the same. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022left\u0022\u003E The left value to compare. \u003C/param\u003E\n        /// \u003Cparam name=\u0022right\u0022\u003E The right value to compare. \u003C/param\u003E\n        public static bool operator !=(FloatExtensibleEnumWithIntValue left, FloatExtensibleEnumWithIntValue right) =\u003E !left.Equals(right);\n\n        /// \u003Csummary\u003E Converts a string to a \u003Csee cref=\u0022FloatExtensibleEnumWithIntValue\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022value\u0022\u003E The value. \u003C/param\u003E\n        public static implicit operator FloatExtensibleEnumWithIntValue(float value) =\u003E new FloatExtensibleEnumWithIntValue(value);\n\n        /// \u003Cparam name=\u0022obj\u0022\u003E The object to compare. \u003C/param\u003E\n        [EditorBrowsableAttribute(EditorBrowsableState.Never)]\n        public override bool Equals(object obj) =\u003E ((obj is FloatExtensibleEnumWithIntValue other) \u0026\u0026 this.Equals(other));\n\n        /// \u003Cparam name=\u0022other\u0022\u003E The instance to compare. \u003C/param\u003E\n        public bool Equals(FloatExtensibleEnumWithIntValue other) =\u003E float.Equals(_value, other._value);\n\n        /// \u003Cinheritdoc/\u003E\n        public override int GetHashCode() =\u003E _value.GetHashCode();\n\n        /// \u003Cinheritdoc/\u003E\n        public override string ToString() =\u003E _value.ToString(CultureInfo.InvariantCulture);\n    }\n}\n"
          }
        },
        {
          "name": "FloatExtensibleEnumWithIntValue.Serialization.cs",
          "typeDeclaration": {
            "name": "FloatExtensibleEnumWithIntValue",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public readonly partial struct FloatExtensibleEnumWithIntValue\n    {\n        internal float ToSerialSingle() =\u003E _value;\n    }\n}\n"
          }
        },
        {
          "name": "FloatFixedEnum.cs",
          "typeDeclaration": {
            "name": "FloatFixedEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E float fixed enum. \u003C/summary\u003E\n    public enum FloatFixedEnum\n    {\n        /// \u003Csummary\u003E OneDotOne. \u003C/summary\u003E\n        OneDotOne,\n        /// \u003Csummary\u003E TwoDotTwo. \u003C/summary\u003E\n        TwoDotTwo,\n        /// \u003Csummary\u003E FourDotFour. \u003C/summary\u003E\n        FourDotFour\n    }\n}\n"
          }
        },
        {
          "name": "FloatFixedEnum.Serialization.cs",
          "typeDeclaration": {
            "name": "FloatFixedEnumExtensions",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    internal static partial class FloatFixedEnumExtensions\n    {\n        public static float ToSerialSingle(this FloatFixedEnum value) =\u003E value switch\n        {\n            FloatFixedEnum.OneDotOne =\u003E 1.1F,\n            FloatFixedEnum.TwoDotTwo =\u003E 2.2F,\n            FloatFixedEnum.FourDotFour =\u003E 4.4F,\n            _ =\u003E throw new ArgumentOutOfRangeException(nameof(value), value, \u0022Unknown FloatFixedEnum value.\u0022)\n        };\n\n        public static FloatFixedEnum ToFloatFixedEnum(this float value)\n        {\n            if ((value == 1.1F))\n            {\n                return FloatFixedEnum.OneDotOne;\n            }\n            if ((value == 2.2F))\n            {\n                return FloatFixedEnum.TwoDotTwo;\n            }\n            if ((value == 4.4F))\n            {\n                return FloatFixedEnum.FourDotFour;\n            }\n            throw new ArgumentOutOfRangeException(nameof(value), value, \u0022Unknown FloatFixedEnum value.\u0022);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "FloatFixedEnumWithIntValue.cs",
          "typeDeclaration": {
            "name": "FloatFixedEnumWithIntValue",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E float fixed enum. \u003C/summary\u003E\n    public enum FloatFixedEnumWithIntValue\n    {\n        /// \u003Csummary\u003E One. \u003C/summary\u003E\n        One = 1,\n        /// \u003Csummary\u003E Two. \u003C/summary\u003E\n        Two = 2,\n        /// \u003Csummary\u003E Four. \u003C/summary\u003E\n        Four = 4\n    }\n}\n"
          }
        },
        {
          "name": "FloatFixedEnumWithIntValue.Serialization.cs",
          "typeDeclaration": {
            "name": "FloatFixedEnumWithIntValueExtensions",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    internal static partial class FloatFixedEnumWithIntValueExtensions\n    {\n        public static FloatFixedEnumWithIntValue ToFloatFixedEnumWithIntValue(this int value)\n        {\n            if ((value == 1))\n            {\n                return FloatFixedEnumWithIntValue.One;\n            }\n            if ((value == 2))\n            {\n                return FloatFixedEnumWithIntValue.Two;\n            }\n            if ((value == 4))\n            {\n                return FloatFixedEnumWithIntValue.Four;\n            }\n            throw new ArgumentOutOfRangeException(nameof(value), value, \u0022Unknown FloatFixedEnumWithIntValue value.\u0022);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "IntFixedEnum.cs",
          "typeDeclaration": {
            "name": "IntFixedEnum",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E int fixed enum. \u003C/summary\u003E\n    public enum IntFixedEnum\n    {\n        /// \u003Csummary\u003E One. \u003C/summary\u003E\n        One = 1,\n        /// \u003Csummary\u003E Two. \u003C/summary\u003E\n        Two = 2,\n        /// \u003Csummary\u003E Four. \u003C/summary\u003E\n        Four = 4\n    }\n}\n"
          }
        },
        {
          "name": "IntFixedEnum.Serialization.cs",
          "typeDeclaration": {
            "name": "IntFixedEnumExtensions",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    internal static partial class IntFixedEnumExtensions\n    {\n        public static IntFixedEnum ToIntFixedEnum(this int value)\n        {\n            if ((value == 1))\n            {\n                return IntFixedEnum.One;\n            }\n            if ((value == 2))\n            {\n                return IntFixedEnum.Two;\n            }\n            if ((value == 4))\n            {\n                return IntFixedEnum.Four;\n            }\n            throw new ArgumentOutOfRangeException(nameof(value), value, \u0022Unknown IntFixedEnum value.\u0022);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "Thing.cs",
          "typeDeclaration": {
            "name": "Thing",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E A model with a few properties of literal types. \u003C/summary\u003E\n    public partial class Thing\n    {\n        /// \u003Csummary\u003E Keeps track of any properties unknown to the library. \u003C/summary\u003E\n        private protected readonly IDictionary\u003Cstring, BinaryData\u003E _additionalBinaryDataProperties;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022Thing\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the Thing. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredUnion\u0022\u003E required Union. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredBadDescription\u0022\u003E description with xml \u0026lt;|endoftext|\u0026gt;. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredNullableList\u0022\u003E required nullable collection. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E, \u003Cparamref name=\u0022requiredUnion\u0022/\u003E or \u003Cparamref name=\u0022requiredBadDescription\u0022/\u003E is null. \u003C/exception\u003E\n        public Thing(string name, BinaryData requiredUnion, string requiredBadDescription, IEnumerable\u003Cint\u003E requiredNullableList)\n        {\n            Argument.AssertNotNull(name, nameof(name));\n            Argument.AssertNotNull(requiredUnion, nameof(requiredUnion));\n            Argument.AssertNotNull(requiredBadDescription, nameof(requiredBadDescription));\n\n            Name = name;\n            RequiredUnion = requiredUnion;\n            RequiredBadDescription = requiredBadDescription;\n            OptionalNullableList = new ChangeTrackingList\u003Cint\u003E();\n            RequiredNullableList = requiredNullableList?.ToList();\n        }\n\n        internal Thing(string name, BinaryData requiredUnion, ThingRequiredLiteralString requiredLiteralString, ThingRequiredLiteralInt requiredLiteralInt, ThingRequiredLiteralFloat requiredLiteralFloat, bool requiredLiteralBool, ThingOptionalLiteralString? optionalLiteralString, ThingOptionalLiteralInt? optionalLiteralInt, ThingOptionalLiteralFloat? optionalLiteralFloat, bool? optionalLiteralBool, string requiredBadDescription, IList\u003Cint\u003E optionalNullableList, IList\u003Cint\u003E requiredNullableList, IDictionary\u003Cstring, BinaryData\u003E additionalBinaryDataProperties)\n        {\n            Name = name;\n            RequiredUnion = requiredUnion;\n            RequiredLiteralString = requiredLiteralString;\n            RequiredLiteralInt = requiredLiteralInt;\n            RequiredLiteralFloat = requiredLiteralFloat;\n            RequiredLiteralBool = requiredLiteralBool;\n            OptionalLiteralString = optionalLiteralString;\n            OptionalLiteralInt = optionalLiteralInt;\n            OptionalLiteralFloat = optionalLiteralFloat;\n            OptionalLiteralBool = optionalLiteralBool;\n            RequiredBadDescription = requiredBadDescription;\n            OptionalNullableList = optionalNullableList;\n            RequiredNullableList = requiredNullableList;\n            _additionalBinaryDataProperties = additionalBinaryDataProperties;\n        }\n\n        /// \u003Csummary\u003E name of the Thing. \u003C/summary\u003E\n        public string Name { get; set; }\n\n        /// \u003Csummary\u003E\n        /// required Union\n        /// \u003Cpara\u003E To assign an object to this property use \u003Csee cref=\u0022BinaryData.FromObjectAsJson{T}(T, JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// \u003Cremarks\u003E\n        /// Supported types:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E \u003Csee cref=\u0022string\u0022/\u003E. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E \u003Csee cref=\u0022IList{T}\u0022/\u003E where \u003Cc\u003ET\u003C/c\u003E is of type \u003Csee cref=\u0022string\u0022/\u003E. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E \u003Csee cref=\u0022int\u0022/\u003E. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/remarks\u003E\n        /// \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public BinaryData RequiredUnion { get; set; }\n\n        /// \u003Csummary\u003E required literal string. \u003C/summary\u003E\n        public ThingRequiredLiteralString RequiredLiteralString { get; } = \u0022accept\u0022;\n\n        /// \u003Csummary\u003E required literal int. \u003C/summary\u003E\n        public ThingRequiredLiteralInt RequiredLiteralInt { get; } = 123;\n\n        /// \u003Csummary\u003E required literal float. \u003C/summary\u003E\n        public ThingRequiredLiteralFloat RequiredLiteralFloat { get; } = 1.23F;\n\n        /// \u003Csummary\u003E required literal bool. \u003C/summary\u003E\n        public bool RequiredLiteralBool { get; } = false;\n\n        /// \u003Csummary\u003E optional literal string. \u003C/summary\u003E\n        public ThingOptionalLiteralString? OptionalLiteralString { get; set; }\n\n        /// \u003Csummary\u003E optional literal int. \u003C/summary\u003E\n        public ThingOptionalLiteralInt? OptionalLiteralInt { get; set; }\n\n        /// \u003Csummary\u003E optional literal float. \u003C/summary\u003E\n        public ThingOptionalLiteralFloat? OptionalLiteralFloat { get; set; }\n\n        /// \u003Csummary\u003E optional literal bool. \u003C/summary\u003E\n        public bool? OptionalLiteralBool { get; set; }\n\n        /// \u003Csummary\u003E description with xml \u0026lt;|endoftext|\u0026gt;. \u003C/summary\u003E\n        public string RequiredBadDescription { get; set; }\n\n        /// \u003Csummary\u003E optional nullable collection. \u003C/summary\u003E\n        public IList\u003Cint\u003E OptionalNullableList { get; set; }\n\n        /// \u003Csummary\u003E required nullable collection. \u003C/summary\u003E\n        public IList\u003Cint\u003E RequiredNullableList { get; set; }\n    }\n}\n"
          }
        },
        {
          "name": "Thing.Serialization.cs",
          "typeDeclaration": {
            "name": "Thing",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public partial class Thing : IJsonModel\u003CThing\u003E\n    {\n        internal Thing()\n        {\n        }\n\n        void IJsonModel\u003CThing\u003E.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)\n        {\n            writer.WriteStartObject();\n            this.JsonModelWriteCore(writer, options);\n            writer.WriteEndObject();\n        }\n\n        /// \u003Cparam name=\u0022writer\u0022\u003E The JSON writer. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CThing\u003E)this).GetFormatFromOptions(options) : options.Format;\n            if ((format != \u0022J\u0022))\n            {\n                throw new FormatException($\u0022The model {nameof(Thing)} does not support writing \u0027{format}\u0027 format.\u0022);\n            }\n            writer.WritePropertyName(\u0022name\u0022u8);\n            writer.WriteStringValue(Name);\n            writer.WritePropertyName(\u0022requiredUnion\u0022u8);\n#if NET6_0_OR_GREATER\n            writer.WriteRawValue(RequiredUnion);\n#else\n            using (JsonDocument document = JsonDocument.Parse(RequiredUnion))\n            {\n                JsonSerializer.Serialize(writer, document.RootElement);\n            }\n#endif\n            writer.WritePropertyName(\u0022requiredLiteralString\u0022u8);\n            writer.WriteStringValue(RequiredLiteralString.ToString());\n            writer.WritePropertyName(\u0022requiredLiteralInt\u0022u8);\n            writer.WriteNumberValue(RequiredLiteralInt.ToSerialInt32());\n            writer.WritePropertyName(\u0022requiredLiteralFloat\u0022u8);\n            writer.WriteNumberValue(RequiredLiteralFloat.ToSerialSingle());\n            writer.WritePropertyName(\u0022requiredLiteralBool\u0022u8);\n            writer.WriteBooleanValue(RequiredLiteralBool);\n            if (Optional.IsDefined(OptionalLiteralString))\n            {\n                writer.WritePropertyName(\u0022optionalLiteralString\u0022u8);\n                writer.WriteStringValue(OptionalLiteralString.Value.ToString());\n            }\n            if (Optional.IsDefined(OptionalLiteralInt))\n            {\n                writer.WritePropertyName(\u0022optionalLiteralInt\u0022u8);\n                writer.WriteNumberValue(OptionalLiteralInt.Value.ToSerialInt32());\n            }\n            if (Optional.IsDefined(OptionalLiteralFloat))\n            {\n                writer.WritePropertyName(\u0022optionalLiteralFloat\u0022u8);\n                writer.WriteNumberValue(OptionalLiteralFloat.Value.ToSerialSingle());\n            }\n            if (Optional.IsDefined(OptionalLiteralBool))\n            {\n                writer.WritePropertyName(\u0022optionalLiteralBool\u0022u8);\n                writer.WriteBooleanValue(OptionalLiteralBool.Value);\n            }\n            writer.WritePropertyName(\u0022requiredBadDescription\u0022u8);\n            writer.WriteStringValue(RequiredBadDescription);\n            if (Optional.IsCollectionDefined(OptionalNullableList))\n            {\n                if ((OptionalNullableList != null))\n                {\n                    writer.WritePropertyName(\u0022optionalNullableList\u0022u8);\n                    writer.WriteStartArray();\n                    foreach (int item in OptionalNullableList)\n                    {\n                        writer.WriteNumberValue(item);\n                    }\n                    writer.WriteEndArray();\n                }\n                else\n                {\n                    writer.WriteNull(\u0022optionalNullableList\u0022u8);\n                }\n            }\n            if (((RequiredNullableList != null) \u0026\u0026 Optional.IsCollectionDefined(RequiredNullableList)))\n            {\n                writer.WritePropertyName(\u0022requiredNullableList\u0022u8);\n                writer.WriteStartArray();\n                foreach (int item in RequiredNullableList)\n                {\n                    writer.WriteNumberValue(item);\n                }\n                writer.WriteEndArray();\n            }\n            else\n            {\n                writer.WriteNull(\u0022requiredNullableList\u0022u8);\n            }\n            if (((options.Format != \u0022W\u0022) \u0026\u0026 (_additionalBinaryDataProperties != null)))\n            {\n                foreach (var item in _additionalBinaryDataProperties)\n                {\n                    writer.WritePropertyName(item.Key);\n#if NET6_0_OR_GREATER\n                    writer.WriteRawValue(item.Value);\n#else\n                    using (JsonDocument document = JsonDocument.Parse(item.Value))\n                    {\n                        JsonSerializer.Serialize(writer, document.RootElement);\n                    }\n#endif\n                }\n            }\n        }\n\n        Thing IJsonModel\u003CThing\u003E.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) =\u003E ((Thing)this.JsonModelCreateCore(ref reader, options));\n\n        /// \u003Cparam name=\u0022reader\u0022\u003E The JSON reader. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual Thing JsonModelCreateCore(ref Utf8JsonReader reader, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CThing\u003E)this).GetFormatFromOptions(options) : options.Format;\n            if ((format != \u0022J\u0022))\n            {\n                throw new FormatException($\u0022The model {nameof(Thing)} does not support reading \u0027{format}\u0027 format.\u0022);\n            }\n            using JsonDocument document = JsonDocument.ParseValue(ref reader);\n            return Thing.DeserializeThing(document.RootElement, options);\n        }\n\n        internal static Thing DeserializeThing(JsonElement element, ModelReaderWriterOptions options)\n        {\n            if ((element.ValueKind == JsonValueKind.Null))\n            {\n                return null;\n            }\n            string name = default;\n            BinaryData requiredUnion = default;\n            ThingRequiredLiteralString requiredLiteralString = default;\n            ThingRequiredLiteralInt requiredLiteralInt = default;\n            ThingRequiredLiteralFloat requiredLiteralFloat = default;\n            bool requiredLiteralBool = default;\n            ThingOptionalLiteralString? optionalLiteralString = default;\n            ThingOptionalLiteralInt? optionalLiteralInt = default;\n            ThingOptionalLiteralFloat? optionalLiteralFloat = default;\n            bool? optionalLiteralBool = default;\n            string requiredBadDescription = default;\n            IList\u003Cint\u003E optionalNullableList = default;\n            IList\u003Cint\u003E requiredNullableList = default;\n            IDictionary\u003Cstring, BinaryData\u003E additionalBinaryDataProperties = new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n            foreach (var prop in element.EnumerateObject())\n            {\n                if (prop.NameEquals(\u0022name\u0022u8))\n                {\n                    name = prop.Value.GetString();\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredUnion\u0022u8))\n                {\n                    requiredUnion = BinaryData.FromString(prop.Value.GetRawText());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredLiteralString\u0022u8))\n                {\n                    requiredLiteralString = new ThingRequiredLiteralString(prop.Value.GetString());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredLiteralInt\u0022u8))\n                {\n                    requiredLiteralInt = new ThingRequiredLiteralInt(prop.Value.GetInt32());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredLiteralFloat\u0022u8))\n                {\n                    requiredLiteralFloat = new ThingRequiredLiteralFloat(prop.Value.GetSingle());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredLiteralBool\u0022u8))\n                {\n                    requiredLiteralBool = prop.Value.GetBoolean();\n                    continue;\n                }\n                if (prop.NameEquals(\u0022optionalLiteralString\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    optionalLiteralString = new ThingOptionalLiteralString(prop.Value.GetString());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022optionalLiteralInt\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    optionalLiteralInt = new ThingOptionalLiteralInt(prop.Value.GetInt32());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022optionalLiteralFloat\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    optionalLiteralFloat = new ThingOptionalLiteralFloat(prop.Value.GetSingle());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022optionalLiteralBool\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    optionalLiteralBool = prop.Value.GetBoolean();\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredBadDescription\u0022u8))\n                {\n                    requiredBadDescription = prop.Value.GetString();\n                    continue;\n                }\n                if (prop.NameEquals(\u0022optionalNullableList\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    List\u003Cint\u003E array = new List\u003Cint\u003E();\n                    foreach (var item in prop.Value.EnumerateArray())\n                    {\n                        array.Add(item.GetInt32());\n                    }\n                    optionalNullableList = array;\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredNullableList\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        requiredNullableList = new ChangeTrackingList\u003Cint\u003E();\n                        continue;\n                    }\n                    List\u003Cint\u003E array = new List\u003Cint\u003E();\n                    foreach (var item in prop.Value.EnumerateArray())\n                    {\n                        array.Add(item.GetInt32());\n                    }\n                    requiredNullableList = array;\n                    continue;\n                }\n                if ((options.Format != \u0022W\u0022))\n                {\n                    additionalBinaryDataProperties.Add(prop.Name, BinaryData.FromString(prop.Value.GetRawText()));\n                }\n            }\n            return new Thing(\n                name,\n                requiredUnion,\n                requiredLiteralString,\n                requiredLiteralInt,\n                requiredLiteralFloat,\n                requiredLiteralBool,\n                optionalLiteralString,\n                optionalLiteralInt,\n                optionalLiteralFloat,\n                optionalLiteralBool,\n                requiredBadDescription,\n                (optionalNullableList ?? new ChangeTrackingList\u003Cint\u003E()),\n                requiredNullableList,\n                additionalBinaryDataProperties);\n        }\n\n        BinaryData IPersistableModel\u003CThing\u003E.Write(ModelReaderWriterOptions options) =\u003E this.PersistableModelWriteCore(options);\n\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CThing\u003E)this).GetFormatFromOptions(options) : options.Format;\n            switch (format)\n            {\n                case \u0022J\u0022:\n                    return ModelReaderWriter.Write(this, options);\n                default:\n                    throw new FormatException($\u0022The model {nameof(Thing)} does not support writing \u0027{options.Format}\u0027 format.\u0022);\n            }\n        }\n\n        Thing IPersistableModel\u003CThing\u003E.Create(BinaryData data, ModelReaderWriterOptions options) =\u003E ((Thing)this.PersistableModelCreateCore(data, options));\n\n        /// \u003Cparam name=\u0022data\u0022\u003E The data to parse. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual Thing PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CThing\u003E)this).GetFormatFromOptions(options) : options.Format;\n            switch (format)\n            {\n                case \u0022J\u0022:\n                    using (JsonDocument document = JsonDocument.Parse(data))\n                    {\n                        return Thing.DeserializeThing(document.RootElement, options);\n                    }\n                default:\n                    throw new FormatException($\u0022The model {nameof(Thing)} does not support reading \u0027{options.Format}\u0027 format.\u0022);\n            }\n        }\n\n        string IPersistableModel\u003CThing\u003E.GetFormatFromOptions(ModelReaderWriterOptions options) =\u003E \u0022J\u0022;\n\n        /// \u003Cparam name=\u0022thing\u0022\u003E The \u003Csee cref=\u0022Thing\u0022/\u003E to serialize into \u003Csee cref=\u0022BinaryContent\u0022/\u003E. \u003C/param\u003E\n        public static implicit operator BinaryContent(Thing thing)\n        {\n            if ((thing == null))\n            {\n                return null;\n            }\n            return BinaryContent.Create(thing, ModelSerializationExtensions.WireOptions);\n        }\n\n        /// \u003Cparam name=\u0022result\u0022\u003E The \u003Csee cref=\u0022ClientResult\u0022/\u003E to deserialize the \u003Csee cref=\u0022Thing\u0022/\u003E from. \u003C/param\u003E\n        public static explicit operator Thing(ClientResult result)\n        {\n            using PipelineResponse response = result.GetRawResponse();\n            using JsonDocument document = JsonDocument.Parse(response.Content);\n            return Thing.DeserializeThing(document.RootElement, ModelSerializationExtensions.WireOptions);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "RoundTripModel.cs",
          "typeDeclaration": {
            "name": "RoundTripModel",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E this is a roundtrip model. \u003C/summary\u003E\n    public partial class RoundTripModel\n    {\n        /// \u003Csummary\u003E Keeps track of any properties unknown to the library. \u003C/summary\u003E\n        private protected readonly IDictionary\u003Cstring, BinaryData\u003E _additionalBinaryDataProperties;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022RoundTripModel\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022requiredString\u0022\u003E Required string, illustrating a reference type property. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredInt\u0022\u003E Required int, illustrating a value type property. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredCollection\u0022\u003E Required collection of enums. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredDictionary\u0022\u003E Required dictionary of enums. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredModel\u0022\u003E Required model. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredUnknown\u0022\u003E required unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredRecordUnknown\u0022\u003E required record of unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022modelWithRequiredNullable\u0022\u003E this is a model with required nullable properties. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredBytes\u0022\u003E Required bytes. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022requiredString\u0022/\u003E, \u003Cparamref name=\u0022requiredCollection\u0022/\u003E, \u003Cparamref name=\u0022requiredDictionary\u0022/\u003E, \u003Cparamref name=\u0022requiredModel\u0022/\u003E, \u003Cparamref name=\u0022requiredUnknown\u0022/\u003E, \u003Cparamref name=\u0022requiredRecordUnknown\u0022/\u003E, \u003Cparamref name=\u0022modelWithRequiredNullable\u0022/\u003E or \u003Cparamref name=\u0022requiredBytes\u0022/\u003E is null. \u003C/exception\u003E\n        public RoundTripModel(string requiredString, int requiredInt, IEnumerable\u003CStringFixedEnum\u003E requiredCollection, IDictionary\u003Cstring, StringExtensibleEnum\u003E requiredDictionary, Thing requiredModel, BinaryData requiredUnknown, IDictionary\u003Cstring, BinaryData\u003E requiredRecordUnknown, ModelWithRequiredNullableProperties modelWithRequiredNullable, BinaryData requiredBytes)\n        {\n            Argument.AssertNotNull(requiredString, nameof(requiredString));\n            Argument.AssertNotNull(requiredCollection, nameof(requiredCollection));\n            Argument.AssertNotNull(requiredDictionary, nameof(requiredDictionary));\n            Argument.AssertNotNull(requiredModel, nameof(requiredModel));\n            Argument.AssertNotNull(requiredUnknown, nameof(requiredUnknown));\n            Argument.AssertNotNull(requiredRecordUnknown, nameof(requiredRecordUnknown));\n            Argument.AssertNotNull(modelWithRequiredNullable, nameof(modelWithRequiredNullable));\n            Argument.AssertNotNull(requiredBytes, nameof(requiredBytes));\n\n            RequiredString = requiredString;\n            RequiredInt = requiredInt;\n            RequiredCollection = requiredCollection.ToList();\n            RequiredDictionary = requiredDictionary;\n            RequiredModel = requiredModel;\n            IntExtensibleEnumCollection = new ChangeTrackingList\u003CIntExtensibleEnum\u003E();\n            FloatExtensibleEnumCollection = new ChangeTrackingList\u003CFloatExtensibleEnum\u003E();\n            FloatFixedEnumCollection = new ChangeTrackingList\u003CFloatFixedEnum\u003E();\n            IntFixedEnumCollection = new ChangeTrackingList\u003CIntFixedEnum\u003E();\n            RequiredUnknown = requiredUnknown;\n            RequiredRecordUnknown = requiredRecordUnknown;\n            OptionalRecordUnknown = new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n            ReadOnlyRequiredRecordUnknown = new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n            ReadOnlyOptionalRecordUnknown = new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n            ModelWithRequiredNullable = modelWithRequiredNullable;\n            RequiredBytes = requiredBytes;\n        }\n\n        internal RoundTripModel(string requiredString, int requiredInt, IList\u003CStringFixedEnum\u003E requiredCollection, IDictionary\u003Cstring, StringExtensibleEnum\u003E requiredDictionary, Thing requiredModel, IntExtensibleEnum? intExtensibleEnum, IList\u003CIntExtensibleEnum\u003E intExtensibleEnumCollection, FloatExtensibleEnum? floatExtensibleEnum, FloatExtensibleEnumWithIntValue? floatExtensibleEnumWithIntValue, IList\u003CFloatExtensibleEnum\u003E floatExtensibleEnumCollection, FloatFixedEnum? floatFixedEnum, FloatFixedEnumWithIntValue? floatFixedEnumWithIntValue, IList\u003CFloatFixedEnum\u003E floatFixedEnumCollection, IntFixedEnum? intFixedEnum, IList\u003CIntFixedEnum\u003E intFixedEnumCollection, StringFixedEnum? stringFixedEnum, BinaryData requiredUnknown, BinaryData optionalUnknown, IDictionary\u003Cstring, BinaryData\u003E requiredRecordUnknown, IDictionary\u003Cstring, BinaryData\u003E optionalRecordUnknown, IReadOnlyDictionary\u003Cstring, BinaryData\u003E readOnlyRequiredRecordUnknown, IReadOnlyDictionary\u003Cstring, BinaryData\u003E readOnlyOptionalRecordUnknown, ModelWithRequiredNullableProperties modelWithRequiredNullable, BinaryData requiredBytes, IDictionary\u003Cstring, BinaryData\u003E additionalBinaryDataProperties)\n        {\n            RequiredString = requiredString;\n            RequiredInt = requiredInt;\n            RequiredCollection = requiredCollection;\n            RequiredDictionary = requiredDictionary;\n            RequiredModel = requiredModel;\n            IntExtensibleEnum = intExtensibleEnum;\n            IntExtensibleEnumCollection = intExtensibleEnumCollection;\n            FloatExtensibleEnum = floatExtensibleEnum;\n            FloatExtensibleEnumWithIntValue = floatExtensibleEnumWithIntValue;\n            FloatExtensibleEnumCollection = floatExtensibleEnumCollection;\n            FloatFixedEnum = floatFixedEnum;\n            FloatFixedEnumWithIntValue = floatFixedEnumWithIntValue;\n            FloatFixedEnumCollection = floatFixedEnumCollection;\n            IntFixedEnum = intFixedEnum;\n            IntFixedEnumCollection = intFixedEnumCollection;\n            StringFixedEnum = stringFixedEnum;\n            RequiredUnknown = requiredUnknown;\n            OptionalUnknown = optionalUnknown;\n            RequiredRecordUnknown = requiredRecordUnknown;\n            OptionalRecordUnknown = optionalRecordUnknown;\n            ReadOnlyRequiredRecordUnknown = readOnlyRequiredRecordUnknown;\n            ReadOnlyOptionalRecordUnknown = readOnlyOptionalRecordUnknown;\n            ModelWithRequiredNullable = modelWithRequiredNullable;\n            RequiredBytes = requiredBytes;\n            _additionalBinaryDataProperties = additionalBinaryDataProperties;\n        }\n\n        /// \u003Csummary\u003E Required string, illustrating a reference type property. \u003C/summary\u003E\n        public string RequiredString { get; set; }\n\n        /// \u003Csummary\u003E Required int, illustrating a value type property. \u003C/summary\u003E\n        public int RequiredInt { get; set; }\n\n        /// \u003Csummary\u003E Required collection of enums. \u003C/summary\u003E\n        public IList\u003CStringFixedEnum\u003E RequiredCollection { get; }\n\n        /// \u003Csummary\u003E Required dictionary of enums. \u003C/summary\u003E\n        public IDictionary\u003Cstring, StringExtensibleEnum\u003E RequiredDictionary { get; }\n\n        /// \u003Csummary\u003E Required model. \u003C/summary\u003E\n        public Thing RequiredModel { get; set; }\n\n        /// \u003Csummary\u003E this is an int based extensible enum. \u003C/summary\u003E\n        public IntExtensibleEnum? IntExtensibleEnum { get; set; }\n\n        /// \u003Csummary\u003E this is a collection of int based extensible enum. \u003C/summary\u003E\n        public IList\u003CIntExtensibleEnum\u003E IntExtensibleEnumCollection { get; }\n\n        /// \u003Csummary\u003E this is a float based extensible enum. \u003C/summary\u003E\n        public FloatExtensibleEnum? FloatExtensibleEnum { get; set; }\n\n        /// \u003Csummary\u003E this is a float based extensible enum. \u003C/summary\u003E\n        public FloatExtensibleEnumWithIntValue? FloatExtensibleEnumWithIntValue { get; set; }\n\n        /// \u003Csummary\u003E this is a collection of float based extensible enum. \u003C/summary\u003E\n        public IList\u003CFloatExtensibleEnum\u003E FloatExtensibleEnumCollection { get; }\n\n        /// \u003Csummary\u003E this is a float based fixed enum. \u003C/summary\u003E\n        public FloatFixedEnum? FloatFixedEnum { get; set; }\n\n        /// \u003Csummary\u003E this is a float based fixed enum. \u003C/summary\u003E\n        public FloatFixedEnumWithIntValue? FloatFixedEnumWithIntValue { get; set; }\n\n        /// \u003Csummary\u003E this is a collection of float based fixed enum. \u003C/summary\u003E\n        public IList\u003CFloatFixedEnum\u003E FloatFixedEnumCollection { get; }\n\n        /// \u003Csummary\u003E this is a int based fixed enum. \u003C/summary\u003E\n        public IntFixedEnum? IntFixedEnum { get; set; }\n\n        /// \u003Csummary\u003E this is a collection of int based fixed enum. \u003C/summary\u003E\n        public IList\u003CIntFixedEnum\u003E IntFixedEnumCollection { get; }\n\n        /// \u003Csummary\u003E this is a string based fixed enum. \u003C/summary\u003E\n        public StringFixedEnum? StringFixedEnum { get; set; }\n\n        /// \u003Csummary\u003E\n        /// required unknown\n        /// \u003Cpara\u003E To assign an object to this property use \u003Csee cref=\u0022BinaryData.FromObjectAsJson{T}(T, JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public BinaryData RequiredUnknown { get; set; }\n\n        /// \u003Csummary\u003E\n        /// optional unknown\n        /// \u003Cpara\u003E To assign an object to this property use \u003Csee cref=\u0022BinaryData.FromObjectAsJson{T}(T, JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public BinaryData OptionalUnknown { get; set; }\n\n        /// \u003Csummary\u003E\n        /// required record of unknown\n        /// \u003Cpara\u003E To assign an object to the value of this property use \u003Csee cref=\u0022BinaryData.FromObjectAsJson{T}(T, JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public IDictionary\u003Cstring, BinaryData\u003E RequiredRecordUnknown { get; }\n\n        /// \u003Csummary\u003E\n        /// optional record of unknown\n        /// \u003Cpara\u003E To assign an object to the value of this property use \u003Csee cref=\u0022BinaryData.FromObjectAsJson{T}(T, JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public IDictionary\u003Cstring, BinaryData\u003E OptionalRecordUnknown { get; }\n\n        /// \u003Csummary\u003E\n        /// required readonly record of unknown\n        /// \u003Cpara\u003E To assign an object to the value of this property use \u003Csee cref=\u0022BinaryData.FromObjectAsJson{T}(T, JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public IReadOnlyDictionary\u003Cstring, BinaryData\u003E ReadOnlyRequiredRecordUnknown { get; }\n\n        /// \u003Csummary\u003E\n        /// optional readonly record of unknown\n        /// \u003Cpara\u003E To assign an object to the value of this property use \u003Csee cref=\u0022BinaryData.FromObjectAsJson{T}(T, JsonSerializerOptions?)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E To assign an already formatted json string to this property use \u003Csee cref=\u0022BinaryData.FromString(string)\u0022/\u003E. \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(\u0022foo\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022\\\u0022foo\\\u0022\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022foo\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromObjectAsJson(new { key = \u0022value\u0022 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromString(\u0022{\\\u0022key\\\u0022: \\\u0022value\\\u0022}\u0022). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of { \u0022key\u0022: \u0022value\u0022 }. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public IReadOnlyDictionary\u003Cstring, BinaryData\u003E ReadOnlyOptionalRecordUnknown { get; }\n\n        /// \u003Csummary\u003E this is a model with required nullable properties. \u003C/summary\u003E\n        public ModelWithRequiredNullableProperties ModelWithRequiredNullable { get; set; }\n\n        /// \u003Csummary\u003E\n        /// Required bytes\n        /// \u003Cpara\u003E\n        /// To assign a byte[] to this property use \u003Csee cref=\u0022BinaryData.FromBytes(byte[])\u0022/\u003E.\n        /// The byte[] will be serialized to a Base64 encoded string.\n        /// \u003C/para\u003E\n        /// \u003Cpara\u003E\n        /// Examples:\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cterm\u003E BinaryData.FromBytes(new byte[] { 1, 2, 3 }). \u003C/term\u003E\n        /// \u003Cdescription\u003E Creates a payload of \u0022AQID\u0022. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/para\u003E\n        /// \u003C/summary\u003E\n        public BinaryData RequiredBytes { get; set; }\n    }\n}\n"
          }
        },
        {
          "name": "RoundTripModel.Serialization.cs",
          "typeDeclaration": {
            "name": "RoundTripModel",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public partial class RoundTripModel : IJsonModel\u003CRoundTripModel\u003E\n    {\n        internal RoundTripModel()\n        {\n        }\n\n        void IJsonModel\u003CRoundTripModel\u003E.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)\n        {\n            writer.WriteStartObject();\n            this.JsonModelWriteCore(writer, options);\n            writer.WriteEndObject();\n        }\n\n        /// \u003Cparam name=\u0022writer\u0022\u003E The JSON writer. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CRoundTripModel\u003E)this).GetFormatFromOptions(options) : options.Format;\n            if ((format != \u0022J\u0022))\n            {\n                throw new FormatException($\u0022The model {nameof(RoundTripModel)} does not support writing \u0027{format}\u0027 format.\u0022);\n            }\n            writer.WritePropertyName(\u0022requiredString\u0022u8);\n            writer.WriteStringValue(RequiredString);\n            writer.WritePropertyName(\u0022requiredInt\u0022u8);\n            writer.WriteStringValue(RequiredInt.ToString());\n            writer.WritePropertyName(\u0022requiredCollection\u0022u8);\n            writer.WriteStartArray();\n            foreach (StringFixedEnum item in RequiredCollection)\n            {\n                writer.WriteStringValue(item.ToSerialString());\n            }\n            writer.WriteEndArray();\n            writer.WritePropertyName(\u0022requiredDictionary\u0022u8);\n            writer.WriteStartObject();\n            foreach (var item in RequiredDictionary)\n            {\n                writer.WritePropertyName(item.Key);\n                writer.WriteStringValue(item.Value.ToString());\n            }\n            writer.WriteEndObject();\n            writer.WritePropertyName(\u0022requiredModel\u0022u8);\n            writer.WriteObjectValue\u003CThing\u003E(RequiredModel, options);\n            if (Optional.IsDefined(IntExtensibleEnum))\n            {\n                writer.WritePropertyName(\u0022intExtensibleEnum\u0022u8);\n                writer.WriteNumberValue(IntExtensibleEnum.Value.ToSerialInt32());\n            }\n            if (Optional.IsCollectionDefined(IntExtensibleEnumCollection))\n            {\n                writer.WritePropertyName(\u0022intExtensibleEnumCollection\u0022u8);\n                writer.WriteStartArray();\n                foreach (IntExtensibleEnum item in IntExtensibleEnumCollection)\n                {\n                    writer.WriteNumberValue(item.ToSerialInt32());\n                }\n                writer.WriteEndArray();\n            }\n            if (Optional.IsDefined(FloatExtensibleEnum))\n            {\n                writer.WritePropertyName(\u0022floatExtensibleEnum\u0022u8);\n                writer.WriteNumberValue(FloatExtensibleEnum.Value.ToSerialSingle());\n            }\n            if (Optional.IsDefined(FloatExtensibleEnumWithIntValue))\n            {\n                writer.WritePropertyName(\u0022floatExtensibleEnumWithIntValue\u0022u8);\n                writer.WriteNumberValue(FloatExtensibleEnumWithIntValue.Value.ToSerialSingle());\n            }\n            if (Optional.IsCollectionDefined(FloatExtensibleEnumCollection))\n            {\n                writer.WritePropertyName(\u0022floatExtensibleEnumCollection\u0022u8);\n                writer.WriteStartArray();\n                foreach (FloatExtensibleEnum item in FloatExtensibleEnumCollection)\n                {\n                    writer.WriteNumberValue(item.ToSerialSingle());\n                }\n                writer.WriteEndArray();\n            }\n            if (Optional.IsDefined(FloatFixedEnum))\n            {\n                writer.WritePropertyName(\u0022floatFixedEnum\u0022u8);\n                writer.WriteNumberValue(FloatFixedEnum.Value.ToSerialSingle());\n            }\n            if (Optional.IsDefined(FloatFixedEnumWithIntValue))\n            {\n                writer.WritePropertyName(\u0022floatFixedEnumWithIntValue\u0022u8);\n                writer.WriteNumberValue(((int)FloatFixedEnumWithIntValue.Value));\n            }\n            if (Optional.IsCollectionDefined(FloatFixedEnumCollection))\n            {\n                writer.WritePropertyName(\u0022floatFixedEnumCollection\u0022u8);\n                writer.WriteStartArray();\n                foreach (FloatFixedEnum item in FloatFixedEnumCollection)\n                {\n                    writer.WriteNumberValue(item.ToSerialSingle());\n                }\n                writer.WriteEndArray();\n            }\n            if (Optional.IsDefined(IntFixedEnum))\n            {\n                writer.WritePropertyName(\u0022intFixedEnum\u0022u8);\n                writer.WriteNumberValue(((int)IntFixedEnum.Value));\n            }\n            if (Optional.IsCollectionDefined(IntFixedEnumCollection))\n            {\n                writer.WritePropertyName(\u0022intFixedEnumCollection\u0022u8);\n                writer.WriteStartArray();\n                foreach (IntFixedEnum item in IntFixedEnumCollection)\n                {\n                    writer.WriteNumberValue(((int)item));\n                }\n                writer.WriteEndArray();\n            }\n            if (Optional.IsDefined(StringFixedEnum))\n            {\n                writer.WritePropertyName(\u0022stringFixedEnum\u0022u8);\n                writer.WriteStringValue(StringFixedEnum.Value.ToSerialString());\n            }\n            writer.WritePropertyName(\u0022requiredUnknown\u0022u8);\n#if NET6_0_OR_GREATER\n            writer.WriteRawValue(RequiredUnknown);\n#else\n            using (JsonDocument document = JsonDocument.Parse(RequiredUnknown))\n            {\n                JsonSerializer.Serialize(writer, document.RootElement);\n            }\n#endif\n            if (Optional.IsDefined(OptionalUnknown))\n            {\n                writer.WritePropertyName(\u0022optionalUnknown\u0022u8);\n#if NET6_0_OR_GREATER\n                writer.WriteRawValue(OptionalUnknown);\n#else\n                using (JsonDocument document = JsonDocument.Parse(OptionalUnknown))\n                {\n                    JsonSerializer.Serialize(writer, document.RootElement);\n                }\n#endif\n            }\n            writer.WritePropertyName(\u0022requiredRecordUnknown\u0022u8);\n            writer.WriteStartObject();\n            foreach (var item in RequiredRecordUnknown)\n            {\n                writer.WritePropertyName(item.Key);\n                if ((item.Value == null))\n                {\n                    writer.WriteNullValue();\n                    continue;\n                }\n#if NET6_0_OR_GREATER\n                writer.WriteRawValue(item.Value);\n#else\n                using (JsonDocument document = JsonDocument.Parse(item.Value))\n                {\n                    JsonSerializer.Serialize(writer, document.RootElement);\n                }\n#endif\n            }\n            writer.WriteEndObject();\n            if (Optional.IsCollectionDefined(OptionalRecordUnknown))\n            {\n                writer.WritePropertyName(\u0022optionalRecordUnknown\u0022u8);\n                writer.WriteStartObject();\n                foreach (var item in OptionalRecordUnknown)\n                {\n                    writer.WritePropertyName(item.Key);\n                    if ((item.Value == null))\n                    {\n                        writer.WriteNullValue();\n                        continue;\n                    }\n#if NET6_0_OR_GREATER\n                    writer.WriteRawValue(item.Value);\n#else\n                    using (JsonDocument document = JsonDocument.Parse(item.Value))\n                    {\n                        JsonSerializer.Serialize(writer, document.RootElement);\n                    }\n#endif\n                }\n                writer.WriteEndObject();\n            }\n            if ((options.Format != \u0022W\u0022))\n            {\n                writer.WritePropertyName(\u0022readOnlyRequiredRecordUnknown\u0022u8);\n                writer.WriteStartObject();\n                foreach (var item in ReadOnlyRequiredRecordUnknown)\n                {\n                    writer.WritePropertyName(item.Key);\n                    if ((item.Value == null))\n                    {\n                        writer.WriteNullValue();\n                        continue;\n                    }\n#if NET6_0_OR_GREATER\n                    writer.WriteRawValue(item.Value);\n#else\n                    using (JsonDocument document = JsonDocument.Parse(item.Value))\n                    {\n                        JsonSerializer.Serialize(writer, document.RootElement);\n                    }\n#endif\n                }\n                writer.WriteEndObject();\n            }\n            if (((options.Format != \u0022W\u0022) \u0026\u0026 Optional.IsCollectionDefined(ReadOnlyOptionalRecordUnknown)))\n            {\n                writer.WritePropertyName(\u0022readOnlyOptionalRecordUnknown\u0022u8);\n                writer.WriteStartObject();\n                foreach (var item in ReadOnlyOptionalRecordUnknown)\n                {\n                    writer.WritePropertyName(item.Key);\n                    if ((item.Value == null))\n                    {\n                        writer.WriteNullValue();\n                        continue;\n                    }\n#if NET6_0_OR_GREATER\n                    writer.WriteRawValue(item.Value);\n#else\n                    using (JsonDocument document = JsonDocument.Parse(item.Value))\n                    {\n                        JsonSerializer.Serialize(writer, document.RootElement);\n                    }\n#endif\n                }\n                writer.WriteEndObject();\n            }\n            writer.WritePropertyName(\u0022modelWithRequiredNullable\u0022u8);\n            writer.WriteObjectValue\u003CModelWithRequiredNullableProperties\u003E(ModelWithRequiredNullable, options);\n            writer.WritePropertyName(\u0022requiredBytes\u0022u8);\n            writer.WriteBase64StringValue(RequiredBytes.ToArray(), \u0022D\u0022);\n            if (((options.Format != \u0022W\u0022) \u0026\u0026 (_additionalBinaryDataProperties != null)))\n            {\n                foreach (var item in _additionalBinaryDataProperties)\n                {\n                    writer.WritePropertyName(item.Key);\n#if NET6_0_OR_GREATER\n                    writer.WriteRawValue(item.Value);\n#else\n                    using (JsonDocument document = JsonDocument.Parse(item.Value))\n                    {\n                        JsonSerializer.Serialize(writer, document.RootElement);\n                    }\n#endif\n                }\n            }\n        }\n\n        RoundTripModel IJsonModel\u003CRoundTripModel\u003E.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) =\u003E ((RoundTripModel)this.JsonModelCreateCore(ref reader, options));\n\n        /// \u003Cparam name=\u0022reader\u0022\u003E The JSON reader. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual RoundTripModel JsonModelCreateCore(ref Utf8JsonReader reader, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CRoundTripModel\u003E)this).GetFormatFromOptions(options) : options.Format;\n            if ((format != \u0022J\u0022))\n            {\n                throw new FormatException($\u0022The model {nameof(RoundTripModel)} does not support reading \u0027{format}\u0027 format.\u0022);\n            }\n            using JsonDocument document = JsonDocument.ParseValue(ref reader);\n            return RoundTripModel.DeserializeRoundTripModel(document.RootElement, options);\n        }\n\n        internal static RoundTripModel DeserializeRoundTripModel(JsonElement element, ModelReaderWriterOptions options)\n        {\n            if ((element.ValueKind == JsonValueKind.Null))\n            {\n                return null;\n            }\n            string requiredString = default;\n            int requiredInt = default;\n            IList\u003CStringFixedEnum\u003E requiredCollection = default;\n            IDictionary\u003Cstring, StringExtensibleEnum\u003E requiredDictionary = default;\n            Thing requiredModel = default;\n            IntExtensibleEnum? intExtensibleEnum = default;\n            IList\u003CIntExtensibleEnum\u003E intExtensibleEnumCollection = default;\n            FloatExtensibleEnum? floatExtensibleEnum = default;\n            FloatExtensibleEnumWithIntValue? floatExtensibleEnumWithIntValue = default;\n            IList\u003CFloatExtensibleEnum\u003E floatExtensibleEnumCollection = default;\n            FloatFixedEnum? floatFixedEnum = default;\n            FloatFixedEnumWithIntValue? floatFixedEnumWithIntValue = default;\n            IList\u003CFloatFixedEnum\u003E floatFixedEnumCollection = default;\n            IntFixedEnum? intFixedEnum = default;\n            IList\u003CIntFixedEnum\u003E intFixedEnumCollection = default;\n            StringFixedEnum? stringFixedEnum = default;\n            BinaryData requiredUnknown = default;\n            BinaryData optionalUnknown = default;\n            IDictionary\u003Cstring, BinaryData\u003E requiredRecordUnknown = default;\n            IDictionary\u003Cstring, BinaryData\u003E optionalRecordUnknown = default;\n            IReadOnlyDictionary\u003Cstring, BinaryData\u003E readOnlyRequiredRecordUnknown = default;\n            IReadOnlyDictionary\u003Cstring, BinaryData\u003E readOnlyOptionalRecordUnknown = default;\n            ModelWithRequiredNullableProperties modelWithRequiredNullable = default;\n            BinaryData requiredBytes = default;\n            IDictionary\u003Cstring, BinaryData\u003E additionalBinaryDataProperties = new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n            foreach (var prop in element.EnumerateObject())\n            {\n                if (prop.NameEquals(\u0022requiredString\u0022u8))\n                {\n                    requiredString = prop.Value.GetString();\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredInt\u0022u8))\n                {\n                    requiredInt = int.Parse(prop.Value.GetString());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredCollection\u0022u8))\n                {\n                    List\u003CStringFixedEnum\u003E array = new List\u003CStringFixedEnum\u003E();\n                    foreach (var item in prop.Value.EnumerateArray())\n                    {\n                        array.Add(item.GetString().ToStringFixedEnum());\n                    }\n                    requiredCollection = array;\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredDictionary\u0022u8))\n                {\n                    Dictionary\u003Cstring, StringExtensibleEnum\u003E dictionary = new Dictionary\u003Cstring, StringExtensibleEnum\u003E();\n                    foreach (var prop0 in prop.Value.EnumerateObject())\n                    {\n                        dictionary.Add(prop0.Name, new StringExtensibleEnum(prop0.Value.GetString()));\n                    }\n                    requiredDictionary = dictionary;\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredModel\u0022u8))\n                {\n                    requiredModel = Thing.DeserializeThing(prop.Value, options);\n                    continue;\n                }\n                if (prop.NameEquals(\u0022intExtensibleEnum\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    intExtensibleEnum = new IntExtensibleEnum(prop.Value.GetInt32());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022intExtensibleEnumCollection\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    List\u003CIntExtensibleEnum\u003E array = new List\u003CIntExtensibleEnum\u003E();\n                    foreach (var item in prop.Value.EnumerateArray())\n                    {\n                        array.Add(new IntExtensibleEnum(item.GetInt32()));\n                    }\n                    intExtensibleEnumCollection = array;\n                    continue;\n                }\n                if (prop.NameEquals(\u0022floatExtensibleEnum\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    floatExtensibleEnum = new FloatExtensibleEnum(prop.Value.GetSingle());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022floatExtensibleEnumWithIntValue\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    floatExtensibleEnumWithIntValue = new FloatExtensibleEnumWithIntValue(prop.Value.GetSingle());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022floatExtensibleEnumCollection\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    List\u003CFloatExtensibleEnum\u003E array = new List\u003CFloatExtensibleEnum\u003E();\n                    foreach (var item in prop.Value.EnumerateArray())\n                    {\n                        array.Add(new FloatExtensibleEnum(item.GetSingle()));\n                    }\n                    floatExtensibleEnumCollection = array;\n                    continue;\n                }\n                if (prop.NameEquals(\u0022floatFixedEnum\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    floatFixedEnum = prop.Value.GetSingle().ToFloatFixedEnum();\n                    continue;\n                }\n                if (prop.NameEquals(\u0022floatFixedEnumWithIntValue\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    floatFixedEnumWithIntValue = prop.Value.GetInt32().ToFloatFixedEnumWithIntValue();\n                    continue;\n                }\n                if (prop.NameEquals(\u0022floatFixedEnumCollection\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    List\u003CFloatFixedEnum\u003E array = new List\u003CFloatFixedEnum\u003E();\n                    foreach (var item in prop.Value.EnumerateArray())\n                    {\n                        array.Add(item.GetSingle().ToFloatFixedEnum());\n                    }\n                    floatFixedEnumCollection = array;\n                    continue;\n                }\n                if (prop.NameEquals(\u0022intFixedEnum\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    intFixedEnum = prop.Value.GetInt32().ToIntFixedEnum();\n                    continue;\n                }\n                if (prop.NameEquals(\u0022intFixedEnumCollection\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    List\u003CIntFixedEnum\u003E array = new List\u003CIntFixedEnum\u003E();\n                    foreach (var item in prop.Value.EnumerateArray())\n                    {\n                        array.Add(item.GetInt32().ToIntFixedEnum());\n                    }\n                    intFixedEnumCollection = array;\n                    continue;\n                }\n                if (prop.NameEquals(\u0022stringFixedEnum\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    stringFixedEnum = prop.Value.GetString().ToStringFixedEnum();\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredUnknown\u0022u8))\n                {\n                    requiredUnknown = BinaryData.FromString(prop.Value.GetRawText());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022optionalUnknown\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    optionalUnknown = BinaryData.FromString(prop.Value.GetRawText());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredRecordUnknown\u0022u8))\n                {\n                    Dictionary\u003Cstring, BinaryData\u003E dictionary = new Dictionary\u003Cstring, BinaryData\u003E();\n                    foreach (var prop0 in prop.Value.EnumerateObject())\n                    {\n                        if ((prop0.Value.ValueKind == JsonValueKind.Null))\n                        {\n                            dictionary.Add(prop0.Name, null);\n                        }\n                        else\n                        {\n                            dictionary.Add(prop0.Name, BinaryData.FromString(prop0.Value.GetRawText()));\n                        }\n                    }\n                    requiredRecordUnknown = dictionary;\n                    continue;\n                }\n                if (prop.NameEquals(\u0022optionalRecordUnknown\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    Dictionary\u003Cstring, BinaryData\u003E dictionary = new Dictionary\u003Cstring, BinaryData\u003E();\n                    foreach (var prop0 in prop.Value.EnumerateObject())\n                    {\n                        if ((prop0.Value.ValueKind == JsonValueKind.Null))\n                        {\n                            dictionary.Add(prop0.Name, null);\n                        }\n                        else\n                        {\n                            dictionary.Add(prop0.Name, BinaryData.FromString(prop0.Value.GetRawText()));\n                        }\n                    }\n                    optionalRecordUnknown = dictionary;\n                    continue;\n                }\n                if (prop.NameEquals(\u0022readOnlyRequiredRecordUnknown\u0022u8))\n                {\n                    Dictionary\u003Cstring, BinaryData\u003E dictionary = new Dictionary\u003Cstring, BinaryData\u003E();\n                    foreach (var prop0 in prop.Value.EnumerateObject())\n                    {\n                        if ((prop0.Value.ValueKind == JsonValueKind.Null))\n                        {\n                            dictionary.Add(prop0.Name, null);\n                        }\n                        else\n                        {\n                            dictionary.Add(prop0.Name, BinaryData.FromString(prop0.Value.GetRawText()));\n                        }\n                    }\n                    readOnlyRequiredRecordUnknown = dictionary;\n                    continue;\n                }\n                if (prop.NameEquals(\u0022readOnlyOptionalRecordUnknown\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        continue;\n                    }\n                    Dictionary\u003Cstring, BinaryData\u003E dictionary = new Dictionary\u003Cstring, BinaryData\u003E();\n                    foreach (var prop0 in prop.Value.EnumerateObject())\n                    {\n                        if ((prop0.Value.ValueKind == JsonValueKind.Null))\n                        {\n                            dictionary.Add(prop0.Name, null);\n                        }\n                        else\n                        {\n                            dictionary.Add(prop0.Name, BinaryData.FromString(prop0.Value.GetRawText()));\n                        }\n                    }\n                    readOnlyOptionalRecordUnknown = dictionary;\n                    continue;\n                }\n                if (prop.NameEquals(\u0022modelWithRequiredNullable\u0022u8))\n                {\n                    modelWithRequiredNullable = ModelWithRequiredNullableProperties.DeserializeModelWithRequiredNullableProperties(prop.Value, options);\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredBytes\u0022u8))\n                {\n                    requiredBytes = BinaryData.FromBytes(prop.Value.GetBytesFromBase64(\u0022D\u0022));\n                    continue;\n                }\n                if ((options.Format != \u0022W\u0022))\n                {\n                    additionalBinaryDataProperties.Add(prop.Name, BinaryData.FromString(prop.Value.GetRawText()));\n                }\n            }\n            return new RoundTripModel(\n                requiredString,\n                requiredInt,\n                requiredCollection,\n                requiredDictionary,\n                requiredModel,\n                intExtensibleEnum,\n                (intExtensibleEnumCollection ?? new ChangeTrackingList\u003CIntExtensibleEnum\u003E()),\n                floatExtensibleEnum,\n                floatExtensibleEnumWithIntValue,\n                (floatExtensibleEnumCollection ?? new ChangeTrackingList\u003CFloatExtensibleEnum\u003E()),\n                floatFixedEnum,\n                floatFixedEnumWithIntValue,\n                (floatFixedEnumCollection ?? new ChangeTrackingList\u003CFloatFixedEnum\u003E()),\n                intFixedEnum,\n                (intFixedEnumCollection ?? new ChangeTrackingList\u003CIntFixedEnum\u003E()),\n                stringFixedEnum,\n                requiredUnknown,\n                optionalUnknown,\n                requiredRecordUnknown,\n                (optionalRecordUnknown ?? new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E()),\n                readOnlyRequiredRecordUnknown,\n                (readOnlyOptionalRecordUnknown ?? new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E()),\n                modelWithRequiredNullable,\n                requiredBytes,\n                additionalBinaryDataProperties);\n        }\n\n        BinaryData IPersistableModel\u003CRoundTripModel\u003E.Write(ModelReaderWriterOptions options) =\u003E this.PersistableModelWriteCore(options);\n\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CRoundTripModel\u003E)this).GetFormatFromOptions(options) : options.Format;\n            switch (format)\n            {\n                case \u0022J\u0022:\n                    return ModelReaderWriter.Write(this, options);\n                default:\n                    throw new FormatException($\u0022The model {nameof(RoundTripModel)} does not support writing \u0027{options.Format}\u0027 format.\u0022);\n            }\n        }\n\n        RoundTripModel IPersistableModel\u003CRoundTripModel\u003E.Create(BinaryData data, ModelReaderWriterOptions options) =\u003E ((RoundTripModel)this.PersistableModelCreateCore(data, options));\n\n        /// \u003Cparam name=\u0022data\u0022\u003E The data to parse. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual RoundTripModel PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CRoundTripModel\u003E)this).GetFormatFromOptions(options) : options.Format;\n            switch (format)\n            {\n                case \u0022J\u0022:\n                    using (JsonDocument document = JsonDocument.Parse(data))\n                    {\n                        return RoundTripModel.DeserializeRoundTripModel(document.RootElement, options);\n                    }\n                default:\n                    throw new FormatException($\u0022The model {nameof(RoundTripModel)} does not support reading \u0027{options.Format}\u0027 format.\u0022);\n            }\n        }\n\n        string IPersistableModel\u003CRoundTripModel\u003E.GetFormatFromOptions(ModelReaderWriterOptions options) =\u003E \u0022J\u0022;\n\n        /// \u003Cparam name=\u0022roundTripModel\u0022\u003E The \u003Csee cref=\u0022RoundTripModel\u0022/\u003E to serialize into \u003Csee cref=\u0022BinaryContent\u0022/\u003E. \u003C/param\u003E\n        public static implicit operator BinaryContent(RoundTripModel roundTripModel)\n        {\n            if ((roundTripModel == null))\n            {\n                return null;\n            }\n            return BinaryContent.Create(roundTripModel, ModelSerializationExtensions.WireOptions);\n        }\n\n        /// \u003Cparam name=\u0022result\u0022\u003E The \u003Csee cref=\u0022ClientResult\u0022/\u003E to deserialize the \u003Csee cref=\u0022RoundTripModel\u0022/\u003E from. \u003C/param\u003E\n        public static explicit operator RoundTripModel(ClientResult result)\n        {\n            using PipelineResponse response = result.GetRawResponse();\n            using JsonDocument document = JsonDocument.Parse(response.Content);\n            return RoundTripModel.DeserializeRoundTripModel(document.RootElement, ModelSerializationExtensions.WireOptions);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "ModelWithRequiredNullableProperties.cs",
          "typeDeclaration": {
            "name": "ModelWithRequiredNullableProperties",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E A model with a few required nullable properties. \u003C/summary\u003E\n    public partial class ModelWithRequiredNullableProperties\n    {\n        /// \u003Csummary\u003E Keeps track of any properties unknown to the library. \u003C/summary\u003E\n        private protected readonly IDictionary\u003Cstring, BinaryData\u003E _additionalBinaryDataProperties;\n\n        /// \u003Csummary\u003E Initializes a new instance of \u003Csee cref=\u0022ModelWithRequiredNullableProperties\u0022/\u003E. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022requiredNullablePrimitive\u0022\u003E required nullable primitive type. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredExtensibleEnum\u0022\u003E required nullable extensible enum type. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredFixedEnum\u0022\u003E required nullable fixed enum type. \u003C/param\u003E\n        public ModelWithRequiredNullableProperties(int? requiredNullablePrimitive, StringExtensibleEnum? requiredExtensibleEnum, StringFixedEnum? requiredFixedEnum)\n        {\n            RequiredNullablePrimitive = requiredNullablePrimitive;\n            RequiredExtensibleEnum = requiredExtensibleEnum;\n            RequiredFixedEnum = requiredFixedEnum;\n        }\n\n        internal ModelWithRequiredNullableProperties(int? requiredNullablePrimitive, StringExtensibleEnum? requiredExtensibleEnum, StringFixedEnum? requiredFixedEnum, IDictionary\u003Cstring, BinaryData\u003E additionalBinaryDataProperties)\n        {\n            RequiredNullablePrimitive = requiredNullablePrimitive;\n            RequiredExtensibleEnum = requiredExtensibleEnum;\n            RequiredFixedEnum = requiredFixedEnum;\n            _additionalBinaryDataProperties = additionalBinaryDataProperties;\n        }\n\n        /// \u003Csummary\u003E required nullable primitive type. \u003C/summary\u003E\n        public int? RequiredNullablePrimitive { get; set; }\n\n        /// \u003Csummary\u003E required nullable extensible enum type. \u003C/summary\u003E\n        public StringExtensibleEnum? RequiredExtensibleEnum { get; set; }\n\n        /// \u003Csummary\u003E required nullable fixed enum type. \u003C/summary\u003E\n        public StringFixedEnum? RequiredFixedEnum { get; set; }\n    }\n}\n"
          }
        },
        {
          "name": "ModelWithRequiredNullableProperties.Serialization.cs",
          "typeDeclaration": {
            "name": "ModelWithRequiredNullableProperties",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public partial class ModelWithRequiredNullableProperties : IJsonModel\u003CModelWithRequiredNullableProperties\u003E\n    {\n        internal ModelWithRequiredNullableProperties()\n        {\n        }\n\n        void IJsonModel\u003CModelWithRequiredNullableProperties\u003E.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)\n        {\n            writer.WriteStartObject();\n            this.JsonModelWriteCore(writer, options);\n            writer.WriteEndObject();\n        }\n\n        /// \u003Cparam name=\u0022writer\u0022\u003E The JSON writer. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CModelWithRequiredNullableProperties\u003E)this).GetFormatFromOptions(options) : options.Format;\n            if ((format != \u0022J\u0022))\n            {\n                throw new FormatException($\u0022The model {nameof(ModelWithRequiredNullableProperties)} does not support writing \u0027{format}\u0027 format.\u0022);\n            }\n            if ((RequiredNullablePrimitive != null))\n            {\n                writer.WritePropertyName(\u0022requiredNullablePrimitive\u0022u8);\n                writer.WriteNumberValue(RequiredNullablePrimitive.Value);\n            }\n            else\n            {\n                writer.WriteNull(\u0022requiredNullablePrimitive\u0022u8);\n            }\n            if ((RequiredExtensibleEnum != null))\n            {\n                writer.WritePropertyName(\u0022requiredExtensibleEnum\u0022u8);\n                writer.WriteStringValue(RequiredExtensibleEnum.Value.ToString());\n            }\n            else\n            {\n                writer.WriteNull(\u0022requiredExtensibleEnum\u0022u8);\n            }\n            if ((RequiredFixedEnum != null))\n            {\n                writer.WritePropertyName(\u0022requiredFixedEnum\u0022u8);\n                writer.WriteStringValue(RequiredFixedEnum.Value.ToSerialString());\n            }\n            else\n            {\n                writer.WriteNull(\u0022requiredFixedEnum\u0022u8);\n            }\n            if (((options.Format != \u0022W\u0022) \u0026\u0026 (_additionalBinaryDataProperties != null)))\n            {\n                foreach (var item in _additionalBinaryDataProperties)\n                {\n                    writer.WritePropertyName(item.Key);\n#if NET6_0_OR_GREATER\n                    writer.WriteRawValue(item.Value);\n#else\n                    using (JsonDocument document = JsonDocument.Parse(item.Value))\n                    {\n                        JsonSerializer.Serialize(writer, document.RootElement);\n                    }\n#endif\n                }\n            }\n        }\n\n        ModelWithRequiredNullableProperties IJsonModel\u003CModelWithRequiredNullableProperties\u003E.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) =\u003E ((ModelWithRequiredNullableProperties)this.JsonModelCreateCore(ref reader, options));\n\n        /// \u003Cparam name=\u0022reader\u0022\u003E The JSON reader. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual ModelWithRequiredNullableProperties JsonModelCreateCore(ref Utf8JsonReader reader, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CModelWithRequiredNullableProperties\u003E)this).GetFormatFromOptions(options) : options.Format;\n            if ((format != \u0022J\u0022))\n            {\n                throw new FormatException($\u0022The model {nameof(ModelWithRequiredNullableProperties)} does not support reading \u0027{format}\u0027 format.\u0022);\n            }\n            using JsonDocument document = JsonDocument.ParseValue(ref reader);\n            return ModelWithRequiredNullableProperties.DeserializeModelWithRequiredNullableProperties(document.RootElement, options);\n        }\n\n        internal static ModelWithRequiredNullableProperties DeserializeModelWithRequiredNullableProperties(JsonElement element, ModelReaderWriterOptions options)\n        {\n            if ((element.ValueKind == JsonValueKind.Null))\n            {\n                return null;\n            }\n            int? requiredNullablePrimitive = default;\n            StringExtensibleEnum? requiredExtensibleEnum = default;\n            StringFixedEnum? requiredFixedEnum = default;\n            IDictionary\u003Cstring, BinaryData\u003E additionalBinaryDataProperties = new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n            foreach (var prop in element.EnumerateObject())\n            {\n                if (prop.NameEquals(\u0022requiredNullablePrimitive\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        requiredNullablePrimitive = null;\n                        continue;\n                    }\n                    requiredNullablePrimitive = prop.Value.GetInt32();\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredExtensibleEnum\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        requiredExtensibleEnum = null;\n                        continue;\n                    }\n                    requiredExtensibleEnum = new StringExtensibleEnum(prop.Value.GetString());\n                    continue;\n                }\n                if (prop.NameEquals(\u0022requiredFixedEnum\u0022u8))\n                {\n                    if ((prop.Value.ValueKind == JsonValueKind.Null))\n                    {\n                        requiredFixedEnum = null;\n                        continue;\n                    }\n                    requiredFixedEnum = prop.Value.GetString().ToStringFixedEnum();\n                    continue;\n                }\n                if ((options.Format != \u0022W\u0022))\n                {\n                    additionalBinaryDataProperties.Add(prop.Name, BinaryData.FromString(prop.Value.GetRawText()));\n                }\n            }\n            return new ModelWithRequiredNullableProperties(requiredNullablePrimitive, requiredExtensibleEnum, requiredFixedEnum, additionalBinaryDataProperties);\n        }\n\n        BinaryData IPersistableModel\u003CModelWithRequiredNullableProperties\u003E.Write(ModelReaderWriterOptions options) =\u003E this.PersistableModelWriteCore(options);\n\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CModelWithRequiredNullableProperties\u003E)this).GetFormatFromOptions(options) : options.Format;\n            switch (format)\n            {\n                case \u0022J\u0022:\n                    return ModelReaderWriter.Write(this, options);\n                default:\n                    throw new FormatException($\u0022The model {nameof(ModelWithRequiredNullableProperties)} does not support writing \u0027{options.Format}\u0027 format.\u0022);\n            }\n        }\n\n        ModelWithRequiredNullableProperties IPersistableModel\u003CModelWithRequiredNullableProperties\u003E.Create(BinaryData data, ModelReaderWriterOptions options) =\u003E ((ModelWithRequiredNullableProperties)this.PersistableModelCreateCore(data, options));\n\n        /// \u003Cparam name=\u0022data\u0022\u003E The data to parse. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual ModelWithRequiredNullableProperties PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CModelWithRequiredNullableProperties\u003E)this).GetFormatFromOptions(options) : options.Format;\n            switch (format)\n            {\n                case \u0022J\u0022:\n                    using (JsonDocument document = JsonDocument.Parse(data))\n                    {\n                        return ModelWithRequiredNullableProperties.DeserializeModelWithRequiredNullableProperties(document.RootElement, options);\n                    }\n                default:\n                    throw new FormatException($\u0022The model {nameof(ModelWithRequiredNullableProperties)} does not support reading \u0027{options.Format}\u0027 format.\u0022);\n            }\n        }\n\n        string IPersistableModel\u003CModelWithRequiredNullableProperties\u003E.GetFormatFromOptions(ModelReaderWriterOptions options) =\u003E \u0022J\u0022;\n\n        /// \u003Cparam name=\u0022modelWithRequiredNullableProperties\u0022\u003E The \u003Csee cref=\u0022ModelWithRequiredNullableProperties\u0022/\u003E to serialize into \u003Csee cref=\u0022BinaryContent\u0022/\u003E. \u003C/param\u003E\n        public static implicit operator BinaryContent(ModelWithRequiredNullableProperties modelWithRequiredNullableProperties)\n        {\n            if ((modelWithRequiredNullableProperties == null))\n            {\n                return null;\n            }\n            return BinaryContent.Create(modelWithRequiredNullableProperties, ModelSerializationExtensions.WireOptions);\n        }\n\n        /// \u003Cparam name=\u0022result\u0022\u003E The \u003Csee cref=\u0022ClientResult\u0022/\u003E to deserialize the \u003Csee cref=\u0022ModelWithRequiredNullableProperties\u0022/\u003E from. \u003C/param\u003E\n        public static explicit operator ModelWithRequiredNullableProperties(ClientResult result)\n        {\n            using PipelineResponse response = result.GetRawResponse();\n            using JsonDocument document = JsonDocument.Parse(response.Content);\n            return ModelWithRequiredNullableProperties.DeserializeModelWithRequiredNullableProperties(document.RootElement, ModelSerializationExtensions.WireOptions);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "Friend.cs",
          "typeDeclaration": {
            "name": "Friend",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E this is not a friendly model but with a friendly name. \u003C/summary\u003E\n    public partial class Friend\n    {\n        /// \u003Csummary\u003E Keeps track of any properties unknown to the library. \u003C/summary\u003E\n        private protected readonly IDictionary\u003Cstring, BinaryData\u003E _additionalBinaryDataProperties;\n\n        internal Friend(string name)\n        {\n            Name = name;\n        }\n\n        internal Friend(string name, IDictionary\u003Cstring, BinaryData\u003E additionalBinaryDataProperties)\n        {\n            Name = name;\n            _additionalBinaryDataProperties = additionalBinaryDataProperties;\n        }\n\n        /// \u003Csummary\u003E name of the NotFriend. \u003C/summary\u003E\n        public string Name { get; }\n    }\n}\n"
          }
        },
        {
          "name": "Friend.Serialization.cs",
          "typeDeclaration": {
            "name": "Friend",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public partial class Friend : IJsonModel\u003CFriend\u003E\n    {\n        internal Friend()\n        {\n        }\n\n        void IJsonModel\u003CFriend\u003E.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)\n        {\n            writer.WriteStartObject();\n            this.JsonModelWriteCore(writer, options);\n            writer.WriteEndObject();\n        }\n\n        /// \u003Cparam name=\u0022writer\u0022\u003E The JSON writer. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CFriend\u003E)this).GetFormatFromOptions(options) : options.Format;\n            if ((format != \u0022J\u0022))\n            {\n                throw new FormatException($\u0022The model {nameof(Friend)} does not support writing \u0027{format}\u0027 format.\u0022);\n            }\n            writer.WritePropertyName(\u0022name\u0022u8);\n            writer.WriteStringValue(Name);\n            if (((options.Format != \u0022W\u0022) \u0026\u0026 (_additionalBinaryDataProperties != null)))\n            {\n                foreach (var item in _additionalBinaryDataProperties)\n                {\n                    writer.WritePropertyName(item.Key);\n#if NET6_0_OR_GREATER\n                    writer.WriteRawValue(item.Value);\n#else\n                    using (JsonDocument document = JsonDocument.Parse(item.Value))\n                    {\n                        JsonSerializer.Serialize(writer, document.RootElement);\n                    }\n#endif\n                }\n            }\n        }\n\n        Friend IJsonModel\u003CFriend\u003E.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) =\u003E ((Friend)this.JsonModelCreateCore(ref reader, options));\n\n        /// \u003Cparam name=\u0022reader\u0022\u003E The JSON reader. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual Friend JsonModelCreateCore(ref Utf8JsonReader reader, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CFriend\u003E)this).GetFormatFromOptions(options) : options.Format;\n            if ((format != \u0022J\u0022))\n            {\n                throw new FormatException($\u0022The model {nameof(Friend)} does not support reading \u0027{format}\u0027 format.\u0022);\n            }\n            using JsonDocument document = JsonDocument.ParseValue(ref reader);\n            return Friend.DeserializeFriend(document.RootElement, options);\n        }\n\n        internal static Friend DeserializeFriend(JsonElement element, ModelReaderWriterOptions options)\n        {\n            if ((element.ValueKind == JsonValueKind.Null))\n            {\n                return null;\n            }\n            string name = default;\n            IDictionary\u003Cstring, BinaryData\u003E additionalBinaryDataProperties = new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n            foreach (var prop in element.EnumerateObject())\n            {\n                if (prop.NameEquals(\u0022name\u0022u8))\n                {\n                    name = prop.Value.GetString();\n                    continue;\n                }\n                if ((options.Format != \u0022W\u0022))\n                {\n                    additionalBinaryDataProperties.Add(prop.Name, BinaryData.FromString(prop.Value.GetRawText()));\n                }\n            }\n            return new Friend(name, additionalBinaryDataProperties);\n        }\n\n        BinaryData IPersistableModel\u003CFriend\u003E.Write(ModelReaderWriterOptions options) =\u003E this.PersistableModelWriteCore(options);\n\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CFriend\u003E)this).GetFormatFromOptions(options) : options.Format;\n            switch (format)\n            {\n                case \u0022J\u0022:\n                    return ModelReaderWriter.Write(this, options);\n                default:\n                    throw new FormatException($\u0022The model {nameof(Friend)} does not support writing \u0027{options.Format}\u0027 format.\u0022);\n            }\n        }\n\n        Friend IPersistableModel\u003CFriend\u003E.Create(BinaryData data, ModelReaderWriterOptions options) =\u003E ((Friend)this.PersistableModelCreateCore(data, options));\n\n        /// \u003Cparam name=\u0022data\u0022\u003E The data to parse. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual Friend PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CFriend\u003E)this).GetFormatFromOptions(options) : options.Format;\n            switch (format)\n            {\n                case \u0022J\u0022:\n                    using (JsonDocument document = JsonDocument.Parse(data))\n                    {\n                        return Friend.DeserializeFriend(document.RootElement, options);\n                    }\n                default:\n                    throw new FormatException($\u0022The model {nameof(Friend)} does not support reading \u0027{options.Format}\u0027 format.\u0022);\n            }\n        }\n\n        string IPersistableModel\u003CFriend\u003E.GetFormatFromOptions(ModelReaderWriterOptions options) =\u003E \u0022J\u0022;\n\n        /// \u003Cparam name=\u0022friend\u0022\u003E The \u003Csee cref=\u0022Friend\u0022/\u003E to serialize into \u003Csee cref=\u0022BinaryContent\u0022/\u003E. \u003C/param\u003E\n        public static implicit operator BinaryContent(Friend friend)\n        {\n            if ((friend == null))\n            {\n                return null;\n            }\n            return BinaryContent.Create(friend, ModelSerializationExtensions.WireOptions);\n        }\n\n        /// \u003Cparam name=\u0022result\u0022\u003E The \u003Csee cref=\u0022ClientResult\u0022/\u003E to deserialize the \u003Csee cref=\u0022Friend\u0022/\u003E from. \u003C/param\u003E\n        public static explicit operator Friend(ClientResult result)\n        {\n            using PipelineResponse response = result.GetRawResponse();\n            using JsonDocument document = JsonDocument.Parse(response.Content);\n            return Friend.DeserializeFriend(document.RootElement, ModelSerializationExtensions.WireOptions);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "ProjectedModel.cs",
          "typeDeclaration": {
            "name": "ProjectedModel",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E this is a model with a projected name. \u003C/summary\u003E\n    public partial class ProjectedModel\n    {\n        /// \u003Csummary\u003E Keeps track of any properties unknown to the library. \u003C/summary\u003E\n        private protected readonly IDictionary\u003Cstring, BinaryData\u003E _additionalBinaryDataProperties;\n\n        internal ProjectedModel(string name)\n        {\n            Name = name;\n        }\n\n        internal ProjectedModel(string name, IDictionary\u003Cstring, BinaryData\u003E additionalBinaryDataProperties)\n        {\n            Name = name;\n            _additionalBinaryDataProperties = additionalBinaryDataProperties;\n        }\n\n        /// \u003Csummary\u003E name of the ModelWithProjectedName. \u003C/summary\u003E\n        public string Name { get; }\n    }\n}\n"
          }
        },
        {
          "name": "ProjectedModel.Serialization.cs",
          "typeDeclaration": {
            "name": "ProjectedModel",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public partial class ProjectedModel : IJsonModel\u003CProjectedModel\u003E\n    {\n        internal ProjectedModel()\n        {\n        }\n\n        void IJsonModel\u003CProjectedModel\u003E.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)\n        {\n            writer.WriteStartObject();\n            this.JsonModelWriteCore(writer, options);\n            writer.WriteEndObject();\n        }\n\n        /// \u003Cparam name=\u0022writer\u0022\u003E The JSON writer. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CProjectedModel\u003E)this).GetFormatFromOptions(options) : options.Format;\n            if ((format != \u0022J\u0022))\n            {\n                throw new FormatException($\u0022The model {nameof(ProjectedModel)} does not support writing \u0027{format}\u0027 format.\u0022);\n            }\n            writer.WritePropertyName(\u0022name\u0022u8);\n            writer.WriteStringValue(Name);\n            if (((options.Format != \u0022W\u0022) \u0026\u0026 (_additionalBinaryDataProperties != null)))\n            {\n                foreach (var item in _additionalBinaryDataProperties)\n                {\n                    writer.WritePropertyName(item.Key);\n#if NET6_0_OR_GREATER\n                    writer.WriteRawValue(item.Value);\n#else\n                    using (JsonDocument document = JsonDocument.Parse(item.Value))\n                    {\n                        JsonSerializer.Serialize(writer, document.RootElement);\n                    }\n#endif\n                }\n            }\n        }\n\n        ProjectedModel IJsonModel\u003CProjectedModel\u003E.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) =\u003E ((ProjectedModel)this.JsonModelCreateCore(ref reader, options));\n\n        /// \u003Cparam name=\u0022reader\u0022\u003E The JSON reader. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual ProjectedModel JsonModelCreateCore(ref Utf8JsonReader reader, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CProjectedModel\u003E)this).GetFormatFromOptions(options) : options.Format;\n            if ((format != \u0022J\u0022))\n            {\n                throw new FormatException($\u0022The model {nameof(ProjectedModel)} does not support reading \u0027{format}\u0027 format.\u0022);\n            }\n            using JsonDocument document = JsonDocument.ParseValue(ref reader);\n            return ProjectedModel.DeserializeProjectedModel(document.RootElement, options);\n        }\n\n        internal static ProjectedModel DeserializeProjectedModel(JsonElement element, ModelReaderWriterOptions options)\n        {\n            if ((element.ValueKind == JsonValueKind.Null))\n            {\n                return null;\n            }\n            string name = default;\n            IDictionary\u003Cstring, BinaryData\u003E additionalBinaryDataProperties = new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n            foreach (var prop in element.EnumerateObject())\n            {\n                if (prop.NameEquals(\u0022name\u0022u8))\n                {\n                    name = prop.Value.GetString();\n                    continue;\n                }\n                if ((options.Format != \u0022W\u0022))\n                {\n                    additionalBinaryDataProperties.Add(prop.Name, BinaryData.FromString(prop.Value.GetRawText()));\n                }\n            }\n            return new ProjectedModel(name, additionalBinaryDataProperties);\n        }\n\n        BinaryData IPersistableModel\u003CProjectedModel\u003E.Write(ModelReaderWriterOptions options) =\u003E this.PersistableModelWriteCore(options);\n\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CProjectedModel\u003E)this).GetFormatFromOptions(options) : options.Format;\n            switch (format)\n            {\n                case \u0022J\u0022:\n                    return ModelReaderWriter.Write(this, options);\n                default:\n                    throw new FormatException($\u0022The model {nameof(ProjectedModel)} does not support writing \u0027{options.Format}\u0027 format.\u0022);\n            }\n        }\n\n        ProjectedModel IPersistableModel\u003CProjectedModel\u003E.Create(BinaryData data, ModelReaderWriterOptions options) =\u003E ((ProjectedModel)this.PersistableModelCreateCore(data, options));\n\n        /// \u003Cparam name=\u0022data\u0022\u003E The data to parse. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual ProjectedModel PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CProjectedModel\u003E)this).GetFormatFromOptions(options) : options.Format;\n            switch (format)\n            {\n                case \u0022J\u0022:\n                    using (JsonDocument document = JsonDocument.Parse(data))\n                    {\n                        return ProjectedModel.DeserializeProjectedModel(document.RootElement, options);\n                    }\n                default:\n                    throw new FormatException($\u0022The model {nameof(ProjectedModel)} does not support reading \u0027{options.Format}\u0027 format.\u0022);\n            }\n        }\n\n        string IPersistableModel\u003CProjectedModel\u003E.GetFormatFromOptions(ModelReaderWriterOptions options) =\u003E \u0022J\u0022;\n\n        /// \u003Cparam name=\u0022projectedModel\u0022\u003E The \u003Csee cref=\u0022ProjectedModel\u0022/\u003E to serialize into \u003Csee cref=\u0022BinaryContent\u0022/\u003E. \u003C/param\u003E\n        public static implicit operator BinaryContent(ProjectedModel projectedModel)\n        {\n            if ((projectedModel == null))\n            {\n                return null;\n            }\n            return BinaryContent.Create(projectedModel, ModelSerializationExtensions.WireOptions);\n        }\n\n        /// \u003Cparam name=\u0022result\u0022\u003E The \u003Csee cref=\u0022ClientResult\u0022/\u003E to deserialize the \u003Csee cref=\u0022ProjectedModel\u0022/\u003E from. \u003C/param\u003E\n        public static explicit operator ProjectedModel(ClientResult result)\n        {\n            using PipelineResponse response = result.GetRawResponse();\n            using JsonDocument document = JsonDocument.Parse(response.Content);\n            return ProjectedModel.DeserializeProjectedModel(document.RootElement, ModelSerializationExtensions.WireOptions);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "ReturnsAnonymousModelResponse.cs",
          "typeDeclaration": {
            "name": "ReturnsAnonymousModelResponse",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E The ReturnsAnonymousModelResponse. \u003C/summary\u003E\n    public partial class ReturnsAnonymousModelResponse\n    {\n        /// \u003Csummary\u003E Keeps track of any properties unknown to the library. \u003C/summary\u003E\n        private protected readonly IDictionary\u003Cstring, BinaryData\u003E _additionalBinaryDataProperties;\n\n        internal ReturnsAnonymousModelResponse()\n        {\n        }\n\n        internal ReturnsAnonymousModelResponse(IDictionary\u003Cstring, BinaryData\u003E additionalBinaryDataProperties)\n        {\n            _additionalBinaryDataProperties = additionalBinaryDataProperties;\n        }\n    }\n}\n"
          }
        },
        {
          "name": "ReturnsAnonymousModelResponse.Serialization.cs",
          "typeDeclaration": {
            "name": "ReturnsAnonymousModelResponse",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public partial class ReturnsAnonymousModelResponse : IJsonModel\u003CReturnsAnonymousModelResponse\u003E\n    {\n        void IJsonModel\u003CReturnsAnonymousModelResponse\u003E.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)\n        {\n            writer.WriteStartObject();\n            this.JsonModelWriteCore(writer, options);\n            writer.WriteEndObject();\n        }\n\n        /// \u003Cparam name=\u0022writer\u0022\u003E The JSON writer. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual void JsonModelWriteCore(Utf8JsonWriter writer, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CReturnsAnonymousModelResponse\u003E)this).GetFormatFromOptions(options) : options.Format;\n            if ((format != \u0022J\u0022))\n            {\n                throw new FormatException($\u0022The model {nameof(ReturnsAnonymousModelResponse)} does not support writing \u0027{format}\u0027 format.\u0022);\n            }\n            if (((options.Format != \u0022W\u0022) \u0026\u0026 (_additionalBinaryDataProperties != null)))\n            {\n                foreach (var item in _additionalBinaryDataProperties)\n                {\n                    writer.WritePropertyName(item.Key);\n#if NET6_0_OR_GREATER\n                    writer.WriteRawValue(item.Value);\n#else\n                    using (JsonDocument document = JsonDocument.Parse(item.Value))\n                    {\n                        JsonSerializer.Serialize(writer, document.RootElement);\n                    }\n#endif\n                }\n            }\n        }\n\n        ReturnsAnonymousModelResponse IJsonModel\u003CReturnsAnonymousModelResponse\u003E.Create(ref Utf8JsonReader reader, ModelReaderWriterOptions options) =\u003E ((ReturnsAnonymousModelResponse)this.JsonModelCreateCore(ref reader, options));\n\n        /// \u003Cparam name=\u0022reader\u0022\u003E The JSON reader. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual ReturnsAnonymousModelResponse JsonModelCreateCore(ref Utf8JsonReader reader, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CReturnsAnonymousModelResponse\u003E)this).GetFormatFromOptions(options) : options.Format;\n            if ((format != \u0022J\u0022))\n            {\n                throw new FormatException($\u0022The model {nameof(ReturnsAnonymousModelResponse)} does not support reading \u0027{format}\u0027 format.\u0022);\n            }\n            using JsonDocument document = JsonDocument.ParseValue(ref reader);\n            return ReturnsAnonymousModelResponse.DeserializeReturnsAnonymousModelResponse(document.RootElement, options);\n        }\n\n        internal static ReturnsAnonymousModelResponse DeserializeReturnsAnonymousModelResponse(JsonElement element, ModelReaderWriterOptions options)\n        {\n            if ((element.ValueKind == JsonValueKind.Null))\n            {\n                return null;\n            }\n            IDictionary\u003Cstring, BinaryData\u003E additionalBinaryDataProperties = new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n            foreach (var prop in element.EnumerateObject())\n            {\n                if ((options.Format != \u0022W\u0022))\n                {\n                    additionalBinaryDataProperties.Add(prop.Name, BinaryData.FromString(prop.Value.GetRawText()));\n                }\n            }\n            return new ReturnsAnonymousModelResponse(additionalBinaryDataProperties);\n        }\n\n        BinaryData IPersistableModel\u003CReturnsAnonymousModelResponse\u003E.Write(ModelReaderWriterOptions options) =\u003E this.PersistableModelWriteCore(options);\n\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual BinaryData PersistableModelWriteCore(ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CReturnsAnonymousModelResponse\u003E)this).GetFormatFromOptions(options) : options.Format;\n            switch (format)\n            {\n                case \u0022J\u0022:\n                    return ModelReaderWriter.Write(this, options);\n                default:\n                    throw new FormatException($\u0022The model {nameof(ReturnsAnonymousModelResponse)} does not support writing \u0027{options.Format}\u0027 format.\u0022);\n            }\n        }\n\n        ReturnsAnonymousModelResponse IPersistableModel\u003CReturnsAnonymousModelResponse\u003E.Create(BinaryData data, ModelReaderWriterOptions options) =\u003E ((ReturnsAnonymousModelResponse)this.PersistableModelCreateCore(data, options));\n\n        /// \u003Cparam name=\u0022data\u0022\u003E The data to parse. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The client options for reading and writing models. \u003C/param\u003E\n        protected virtual ReturnsAnonymousModelResponse PersistableModelCreateCore(BinaryData data, ModelReaderWriterOptions options)\n        {\n            string format = (options.Format == \u0022W\u0022) ? ((IPersistableModel\u003CReturnsAnonymousModelResponse\u003E)this).GetFormatFromOptions(options) : options.Format;\n            switch (format)\n            {\n                case \u0022J\u0022:\n                    using (JsonDocument document = JsonDocument.Parse(data))\n                    {\n                        return ReturnsAnonymousModelResponse.DeserializeReturnsAnonymousModelResponse(document.RootElement, options);\n                    }\n                default:\n                    throw new FormatException($\u0022The model {nameof(ReturnsAnonymousModelResponse)} does not support reading \u0027{options.Format}\u0027 format.\u0022);\n            }\n        }\n\n        string IPersistableModel\u003CReturnsAnonymousModelResponse\u003E.GetFormatFromOptions(ModelReaderWriterOptions options) =\u003E \u0022J\u0022;\n\n        /// \u003Cparam name=\u0022returnsAnonymousModelResponse\u0022\u003E The \u003Csee cref=\u0022ReturnsAnonymousModelResponse\u0022/\u003E to serialize into \u003Csee cref=\u0022BinaryContent\u0022/\u003E. \u003C/param\u003E\n        public static implicit operator BinaryContent(ReturnsAnonymousModelResponse returnsAnonymousModelResponse)\n        {\n            if ((returnsAnonymousModelResponse == null))\n            {\n                return null;\n            }\n            return BinaryContent.Create(returnsAnonymousModelResponse, ModelSerializationExtensions.WireOptions);\n        }\n\n        /// \u003Cparam name=\u0022result\u0022\u003E The \u003Csee cref=\u0022ClientResult\u0022/\u003E to deserialize the \u003Csee cref=\u0022ReturnsAnonymousModelResponse\u0022/\u003E from. \u003C/param\u003E\n        public static explicit operator ReturnsAnonymousModelResponse(ClientResult result)\n        {\n            using PipelineResponse response = result.GetRawResponse();\n            using JsonDocument document = JsonDocument.Parse(response.Content);\n            return ReturnsAnonymousModelResponse.DeserializeReturnsAnonymousModelResponse(document.RootElement, ModelSerializationExtensions.WireOptions);\n        }\n    }\n}\n"
          }
        }
      ]
    },
    {
      "name": "./src/Generated/Internal",
      "files": [
        {
          "name": "ChangeTrackingList.cs",
          "typeDeclaration": {
            "name": "ChangeTrackingList",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace UnbrandedTypeSpec\n{\n    internal partial class ChangeTrackingList\u003CT\u003E : IList\u003CT\u003E, IReadOnlyList\u003CT\u003E\n    {\n        private IList\u003CT\u003E _innerList;\n\n        public ChangeTrackingList()\n        {\n        }\n\n        public ChangeTrackingList(IList\u003CT\u003E innerList)\n        {\n            if ((innerList != null))\n            {\n                _innerList = innerList;\n            }\n        }\n\n        public ChangeTrackingList(IReadOnlyList\u003CT\u003E innerList)\n        {\n            if ((innerList != null))\n            {\n                _innerList = innerList.ToList();\n            }\n        }\n\n        public bool IsUndefined =\u003E (_innerList == null);\n\n        public int Count =\u003E this.IsUndefined ? 0 : this.EnsureList().Count;\n\n        public bool IsReadOnly =\u003E this.IsUndefined ? false : this.EnsureList().IsReadOnly;\n\n        public T this[int index]\n        {\n            get\n            {\n                if (this.IsUndefined)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(index));\n                }\n                return this.EnsureList()[index];\n            }\n            set\n            {\n                if (this.IsUndefined)\n                {\n                    throw new ArgumentOutOfRangeException(nameof(index));\n                }\n                this.EnsureList()[index] = value;\n            }\n        }\n\n        public void Reset()\n        {\n            _innerList = null;\n        }\n\n        public IEnumerator\u003CT\u003E GetEnumerator()\n        {\n            if (this.IsUndefined)\n            {\n                IEnumerator\u003CT\u003E enumerateEmpty()\n                {\n                    yield break;\n                }\n                return enumerateEmpty();\n            }\n            return this.EnsureList().GetEnumerator();\n        }\n\n        IEnumerator IEnumerable.GetEnumerator()\n        {\n            return this.GetEnumerator();\n        }\n\n        public void Add(T item)\n        {\n            this.EnsureList().Add(item);\n        }\n\n        public void Clear()\n        {\n            this.EnsureList().Clear();\n        }\n\n        public bool Contains(T item)\n        {\n            if (this.IsUndefined)\n            {\n                return false;\n            }\n            return this.EnsureList().Contains(item);\n        }\n\n        public void CopyTo(T[] array, int arrayIndex)\n        {\n            if (this.IsUndefined)\n            {\n                return;\n            }\n            this.EnsureList().CopyTo(array, arrayIndex);\n        }\n\n        public bool Remove(T item)\n        {\n            if (this.IsUndefined)\n            {\n                return false;\n            }\n            return this.EnsureList().Remove(item);\n        }\n\n        public int IndexOf(T item)\n        {\n            if (this.IsUndefined)\n            {\n                return -1;\n            }\n            return this.EnsureList().IndexOf(item);\n        }\n\n        public void Insert(int index, T item)\n        {\n            this.EnsureList().Insert(index, item);\n        }\n\n        public void RemoveAt(int index)\n        {\n            if (this.IsUndefined)\n            {\n                throw new ArgumentOutOfRangeException(nameof(index));\n            }\n            this.EnsureList().RemoveAt(index);\n        }\n\n        public IList\u003CT\u003E EnsureList()\n        {\n            return (_innerList ??= new List\u003CT\u003E());\n        }\n    }\n}\n"
          }
        },
        {
          "name": "ChangeTrackingDictionary.cs",
          "typeDeclaration": {
            "name": "ChangeTrackingDictionary",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace UnbrandedTypeSpec\n{\n    internal partial class ChangeTrackingDictionary\u003CTKey, TValue\u003E : IDictionary\u003CTKey, TValue\u003E, IReadOnlyDictionary\u003CTKey, TValue\u003E\n        where TKey : notnull\n    {\n        private IDictionary\u003CTKey, TValue\u003E _innerDictionary;\n\n        public ChangeTrackingDictionary()\n        {\n        }\n\n        public ChangeTrackingDictionary(IDictionary\u003CTKey, TValue\u003E dictionary)\n        {\n            if ((dictionary == null))\n            {\n                return;\n            }\n            _innerDictionary = new Dictionary\u003CTKey, TValue\u003E(dictionary);\n        }\n\n        public ChangeTrackingDictionary(IReadOnlyDictionary\u003CTKey, TValue\u003E dictionary)\n        {\n            if ((dictionary == null))\n            {\n                return;\n            }\n            _innerDictionary = new Dictionary\u003CTKey, TValue\u003E();\n            foreach (var pair in dictionary)\n            {\n                _innerDictionary.Add(pair);\n            }\n        }\n\n        public bool IsUndefined =\u003E (_innerDictionary == null);\n\n        public int Count =\u003E this.IsUndefined ? 0 : this.EnsureDictionary().Count;\n\n        public bool IsReadOnly =\u003E this.IsUndefined ? false : this.EnsureDictionary().IsReadOnly;\n\n        public ICollection\u003CTKey\u003E Keys =\u003E this.IsUndefined ? Array.Empty\u003CTKey\u003E() : this.EnsureDictionary().Keys;\n\n        public ICollection\u003CTValue\u003E Values =\u003E this.IsUndefined ? Array.Empty\u003CTValue\u003E() : this.EnsureDictionary().Values;\n\n        public TValue this[TKey key]\n        {\n            get\n            {\n                if (this.IsUndefined)\n                {\n                    throw new KeyNotFoundException(nameof(key));\n                }\n                return this.EnsureDictionary()[key];\n            }\n            set\n            {\n                this.EnsureDictionary()[key] = value;\n            }\n        }\n\n        IEnumerable\u003CTKey\u003E IReadOnlyDictionary\u003CTKey, TValue\u003E.Keys =\u003E this.Keys;\n\n        IEnumerable\u003CTValue\u003E IReadOnlyDictionary\u003CTKey, TValue\u003E.Values =\u003E this.Values;\n\n        public IEnumerator\u003CKeyValuePair\u003CTKey, TValue\u003E\u003E GetEnumerator()\n        {\n            if (this.IsUndefined)\n            {\n                IEnumerator\u003CKeyValuePair\u003CTKey, TValue\u003E\u003E enumerateEmpty()\n                {\n                    yield break;\n                }\n                return enumerateEmpty();\n            }\n            return this.EnsureDictionary().GetEnumerator();\n        }\n\n        IEnumerator IEnumerable.GetEnumerator()\n        {\n            return this.GetEnumerator();\n        }\n\n        public void Add(KeyValuePair\u003CTKey, TValue\u003E item)\n        {\n            this.EnsureDictionary().Add(item);\n        }\n\n        public void Clear()\n        {\n            this.EnsureDictionary().Clear();\n        }\n\n        public bool Contains(KeyValuePair\u003CTKey, TValue\u003E item)\n        {\n            if (this.IsUndefined)\n            {\n                return false;\n            }\n            return this.EnsureDictionary().Contains(item);\n        }\n\n        public void CopyTo(KeyValuePair\u003CTKey, TValue\u003E[] array, int index)\n        {\n            if (this.IsUndefined)\n            {\n                return;\n            }\n            this.EnsureDictionary().CopyTo(array, index);\n        }\n\n        public bool Remove(KeyValuePair\u003CTKey, TValue\u003E item)\n        {\n            if (this.IsUndefined)\n            {\n                return false;\n            }\n            return this.EnsureDictionary().Remove(item);\n        }\n\n        public void Add(TKey key, TValue value)\n        {\n            this.EnsureDictionary().Add(key, value);\n        }\n\n        public bool ContainsKey(TKey key)\n        {\n            if (this.IsUndefined)\n            {\n                return false;\n            }\n            return this.EnsureDictionary().ContainsKey(key);\n        }\n\n        public bool Remove(TKey key)\n        {\n            if (this.IsUndefined)\n            {\n                return false;\n            }\n            return this.EnsureDictionary().Remove(key);\n        }\n\n        public bool TryGetValue(TKey key, out TValue value)\n        {\n            if (this.IsUndefined)\n            {\n                value = default;\n                return false;\n            }\n            return this.EnsureDictionary().TryGetValue(key, out value);\n        }\n\n        public IDictionary\u003CTKey, TValue\u003E EnsureDictionary()\n        {\n            return (_innerDictionary ??= new Dictionary\u003CTKey, TValue\u003E());\n        }\n    }\n}\n"
          }
        },
        {
          "name": "Argument.cs",
          "typeDeclaration": {
            "name": "Argument",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class Argument\n    {\n        public static void AssertNotNull\u003CT\u003E(T value, string name)\n        {\n            if ((value is null))\n            {\n                throw new ArgumentNullException(name);\n            }\n        }\n\n        public static void AssertNotNull\u003CT\u003E(T? value, string name)\n            where T : struct \n        {\n            if (!value.HasValue)\n            {\n                throw new ArgumentNullException(name);\n            }\n        }\n\n        public static void AssertNotNullOrEmpty\u003CT\u003E(IEnumerable\u003CT\u003E value, string name)\n        {\n            if ((value is null))\n            {\n                throw new ArgumentNullException(name);\n            }\n            if (((value is ICollection\u003CT\u003E collectionOfT) \u0026\u0026 (collectionOfT.Count == 0)))\n            {\n                throw new ArgumentException(\u0022Value cannot be an empty collection.\u0022, name);\n            }\n            if (((value is ICollection collection) \u0026\u0026 (collection.Count == 0)))\n            {\n                throw new ArgumentException(\u0022Value cannot be an empty collection.\u0022, name);\n            }\n            using IEnumerator\u003CT\u003E e = value.GetEnumerator();\n            if (!e.MoveNext())\n            {\n                throw new ArgumentException(\u0022Value cannot be an empty collection.\u0022, name);\n            }\n        }\n\n        public static void AssertNotNullOrEmpty(string value, string name)\n        {\n            if ((value is null))\n            {\n                throw new ArgumentNullException(name);\n            }\n            if ((value.Length == 0))\n            {\n                throw new ArgumentException(\u0022Value cannot be an empty string.\u0022, name);\n            }\n        }\n\n        public static void AssertNotNullOrWhiteSpace(string value, string name)\n        {\n            if ((value is null))\n            {\n                throw new ArgumentNullException(name);\n            }\n            if (string.IsNullOrWhiteSpace(value))\n            {\n                throw new ArgumentException(\u0022Value cannot be empty or contain only white-space characters.\u0022, name);\n            }\n        }\n\n        public static void AssertNotDefault\u003CT\u003E(ref T value, string name)\n            where T : struct, IEquatable\u003CT\u003E \n        {\n            if (value.Equals(default))\n            {\n                throw new ArgumentException(\u0022Value cannot be empty.\u0022, name);\n            }\n        }\n\n        public static void AssertInRange\u003CT\u003E(T value, T minimum, T maximum, string name)\n            where T : notnull, IComparable\u003CT\u003E \n        {\n            if ((minimum.CompareTo(value) \u003E 0))\n            {\n                throw new ArgumentOutOfRangeException(name, \u0022Value is less than the minimum allowed.\u0022);\n            }\n            if ((maximum.CompareTo(value) \u003C 0))\n            {\n                throw new ArgumentOutOfRangeException(name, \u0022Value is greater than the maximum allowed.\u0022);\n            }\n        }\n\n        public static void AssertEnumDefined(Type enumType, object value, string name)\n        {\n            if (!Enum.IsDefined(enumType, value))\n            {\n                throw new ArgumentException($\u0022Value not defined for {enumType.FullName}.\u0022, name);\n            }\n        }\n\n        public static T CheckNotNull\u003CT\u003E(T value, string name)\n            where T : class \n        {\n            Argument.AssertNotNull(value, name);\n            return value;\n        }\n\n        public static string CheckNotNullOrEmpty(string value, string name)\n        {\n            Argument.AssertNotNullOrEmpty(value, name);\n            return value;\n        }\n\n        public static void AssertNull\u003CT\u003E(T value, string name, string message = ((string)null))\n        {\n            if ((value != null))\n            {\n                throw new ArgumentException((message ?? \u0022Value must be null.\u0022), name);\n            }\n        }\n    }\n}\n"
          }
        },
        {
          "name": "Optional.cs",
          "typeDeclaration": {
            "name": "Optional",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System.Collections.Generic;\nusing System.Text.Json;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class Optional\n    {\n        public static bool IsCollectionDefined\u003CT\u003E(IEnumerable\u003CT\u003E collection)\n        {\n            return !((collection is ChangeTrackingList\u003CT\u003E changeTrackingList) \u0026\u0026 changeTrackingList.IsUndefined);\n        }\n\n        public static bool IsCollectionDefined\u003CTKey, TValue\u003E(IDictionary\u003CTKey, TValue\u003E collection)\n        {\n            return !((collection is ChangeTrackingDictionary\u003CTKey, TValue\u003E changeTrackingDictionary) \u0026\u0026 changeTrackingDictionary.IsUndefined);\n        }\n\n        public static bool IsCollectionDefined\u003CTKey, TValue\u003E(IReadOnlyDictionary\u003CTKey, TValue\u003E collection)\n        {\n            return !((collection is ChangeTrackingDictionary\u003CTKey, TValue\u003E changeTrackingDictionary) \u0026\u0026 changeTrackingDictionary.IsUndefined);\n        }\n\n        public static bool IsDefined\u003CT\u003E(T? value)\n            where T : struct \n        {\n            return value.HasValue;\n        }\n\n        public static bool IsDefined(object value)\n        {\n            return (value != null);\n        }\n\n        public static bool IsDefined(string value)\n        {\n            return (value != null);\n        }\n\n        public static bool IsDefined(JsonElement value)\n        {\n            return (value.ValueKind != JsonValueKind.Undefined);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "ModelSerializationExtensions.cs",
          "typeDeclaration": {
            "name": "ModelSerializationExtensions",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.Text.Json;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class ModelSerializationExtensions\n    {\n        internal static readonly ModelReaderWriterOptions WireOptions = new ModelReaderWriterOptions(\u0022W\u0022);\n\n        public static object GetObject(this JsonElement element)\n        {\n            switch (element.ValueKind)\n            {\n                case JsonValueKind.String:\n                    return element.GetString();\n                case JsonValueKind.Number:\n                    if (element.TryGetInt32(out int intValue))\n                    {\n                        return intValue;\n                    }\n                    if (element.TryGetInt64(out long longValue))\n                    {\n                        return longValue;\n                    }\n                    return element.GetDouble();\n                case JsonValueKind.True:\n                    return true;\n                case JsonValueKind.False:\n                    return false;\n                case JsonValueKind.Undefined:\n                case JsonValueKind.Null:\n                    return null;\n                case JsonValueKind.Object:\n                    Dictionary\u003Cstring, object\u003E dictionary = new Dictionary\u003Cstring, object\u003E();\n                    foreach (var jsonProperty in element.EnumerateObject())\n                    {\n                        dictionary.Add(jsonProperty.Name, jsonProperty.Value.GetObject());\n                    }\n                    return dictionary;\n                case JsonValueKind.Array:\n                    List\u003Cobject\u003E list = new List\u003Cobject\u003E();\n                    foreach (var item in element.EnumerateArray())\n                    {\n                        list.Add(item.GetObject());\n                    }\n                    return list.ToArray();\n                default:\n                    throw new NotSupportedException($\u0022Not supported value kind {element.ValueKind}\u0022);\n            }\n        }\n\n        public static Byte[] GetBytesFromBase64(this JsonElement element, string format)\n        {\n            if ((element.ValueKind == JsonValueKind.Null))\n            {\n                return null;\n            }\n\n            return format switch\n            {\n                \u0022U\u0022 =\u003E TypeFormatters.FromBase64UrlString(element.GetRequiredString()),\n                \u0022D\u0022 =\u003E element.GetBytesFromBase64(),\n                _ =\u003E throw new ArgumentException($\u0022Format is not supported: \u0027{format}\u0027\u0022, nameof(format))\n            };\n        }\n\n        public static DateTimeOffset GetDateTimeOffset(this JsonElement element, string format) =\u003E format switch\n        {\n            \u0022U\u0022 when (element.ValueKind == JsonValueKind.Number) =\u003E DateTimeOffset.FromUnixTimeSeconds(element.GetInt64()),\n            _ =\u003E TypeFormatters.ParseDateTimeOffset(element.GetString(), format)\n        };\n\n        public static TimeSpan GetTimeSpan(this JsonElement element, string format) =\u003E TypeFormatters.ParseTimeSpan(element.GetString(), format);\n\n        public static char GetChar(this JsonElement element)\n        {\n            if ((element.ValueKind == JsonValueKind.String))\n            {\n                string text = element.GetString();\n                if (((text == null) || (text.Length != 1)))\n                {\n                    throw new NotSupportedException($\u0022Cannot convert \\\u0022{text}\\\u0022 to a char\u0022);\n                }\n                return text[0];\n            }\n            else\n            {\n                throw new NotSupportedException($\u0022Cannot convert {element.ValueKind} to a char\u0022);\n            }\n        }\n\n        [ConditionalAttribute(\u0022DEBUG\u0022)]\n        public static void ThrowNonNullablePropertyIsNull(this JsonProperty @property)\n        {\n            throw new JsonException($\u0022A property \u0027{@property.Name}\u0027 defined as non-nullable but received as null from the service. This exception only happens in DEBUG builds of the library and would be ignored in the release build\u0022);\n        }\n\n        public static string GetRequiredString(this JsonElement element)\n        {\n            string value = element.GetString();\n            if ((value == null))\n            {\n                throw new InvalidOperationException($\u0022The requested operation requires an element of type \u0027String\u0027, but the target element has type \u0027{element.ValueKind}\u0027.\u0022);\n            }\n            return value;\n        }\n\n        public static void WriteStringValue(this Utf8JsonWriter writer, DateTimeOffset value, string format)\n        {\n            writer.WriteStringValue(TypeFormatters.ToString(value, format));\n        }\n\n        public static void WriteStringValue(this Utf8JsonWriter writer, DateTime value, string format)\n        {\n            writer.WriteStringValue(TypeFormatters.ToString(value, format));\n        }\n\n        public static void WriteStringValue(this Utf8JsonWriter writer, TimeSpan value, string format)\n        {\n            writer.WriteStringValue(TypeFormatters.ToString(value, format));\n        }\n\n        public static void WriteStringValue(this Utf8JsonWriter writer, char value)\n        {\n            writer.WriteStringValue(value.ToString(CultureInfo.InvariantCulture));\n        }\n\n        public static void WriteBase64StringValue(this Utf8JsonWriter writer, Byte[] value, string format)\n        {\n            if ((value == null))\n            {\n                writer.WriteNullValue();\n                return;\n            }\n            switch (format)\n            {\n                case \u0022U\u0022:\n                    writer.WriteStringValue(TypeFormatters.ToBase64UrlString(value));\n                    break;\n                case \u0022D\u0022:\n                    writer.WriteBase64StringValue(value);\n                    break;\n                default:\n                    throw new ArgumentException($\u0022Format is not supported: \u0027{format}\u0027\u0022, nameof(format));\n            }\n        }\n\n        public static void WriteNumberValue(this Utf8JsonWriter writer, DateTimeOffset value, string format)\n        {\n            if ((format != \u0022U\u0022))\n            {\n                throw new ArgumentOutOfRangeException(nameof(format), \u0022Only \u0027U\u0027 format is supported when writing a DateTimeOffset as a Number.\u0022);\n            }\n            writer.WriteNumberValue(value.ToUnixTimeSeconds());\n        }\n\n        public static void WriteObjectValue\u003CT\u003E(this Utf8JsonWriter writer, T value, ModelReaderWriterOptions options = ((ModelReaderWriterOptions)null))\n        {\n            switch (value)\n            {\n                case null:\n                    writer.WriteNullValue();\n                    break;\n                case IJsonModel\u003CT\u003E jsonModel:\n                    jsonModel.Write(writer, (options ?? ModelSerializationExtensions.WireOptions));\n                    break;\n                case Byte[] bytes:\n                    writer.WriteBase64StringValue(bytes);\n                    break;\n                case BinaryData bytes0:\n                    writer.WriteBase64StringValue(bytes0);\n                    break;\n                case JsonElement json:\n                    json.WriteTo(writer);\n                    break;\n                case int i:\n                    writer.WriteNumberValue(i);\n                    break;\n                case decimal d:\n                    writer.WriteNumberValue(d);\n                    break;\n                case double d0:\n                    if (double.IsNaN(d0))\n                    {\n                        writer.WriteStringValue(\u0022NaN\u0022);\n                    }\n                    else\n                    {\n                        writer.WriteNumberValue(d0);\n                    }\n                    break;\n                case float f:\n                    writer.WriteNumberValue(f);\n                    break;\n                case long l:\n                    writer.WriteNumberValue(l);\n                    break;\n                case string s:\n                    writer.WriteStringValue(s);\n                    break;\n                case bool b:\n                    writer.WriteBooleanValue(b);\n                    break;\n                case Guid g:\n                    writer.WriteStringValue(g);\n                    break;\n                case DateTimeOffset dateTimeOffset:\n                    writer.WriteStringValue(dateTimeOffset, \u0022O\u0022);\n                    break;\n                case DateTime dateTime:\n                    writer.WriteStringValue(dateTime, \u0022O\u0022);\n                    break;\n                case IEnumerable\u003CKeyValuePair\u003Cstring, object\u003E\u003E enumerable:\n                    writer.WriteStartObject();\n                    foreach (var pair in enumerable)\n                    {\n                        writer.WritePropertyName(pair.Key);\n                        writer.WriteObjectValue\u003Cobject\u003E(pair.Value, options);\n                    }\n                    writer.WriteEndObject();\n                    break;\n                case IEnumerable\u003Cobject\u003E objectEnumerable:\n                    writer.WriteStartArray();\n                    foreach (var item in objectEnumerable)\n                    {\n                        writer.WriteObjectValue\u003Cobject\u003E(item, options);\n                    }\n                    writer.WriteEndArray();\n                    break;\n                case TimeSpan timeSpan:\n                    writer.WriteStringValue(timeSpan, \u0022P\u0022);\n                    break;\n                default:\n                    throw new NotSupportedException($\u0022Not supported type {value.GetType()}\u0022);\n            }\n        }\n\n        public static void WriteObjectValue(this Utf8JsonWriter writer, object value, ModelReaderWriterOptions options = ((ModelReaderWriterOptions)null))\n        {\n            writer.WriteObjectValue\u003Cobject\u003E(value, options);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "TypeFormatters.cs",
          "typeDeclaration": {
            "name": "TypeFormatters",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Xml;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class TypeFormatters\n    {\n        private const string RoundtripZFormat = \u0022yyyy-MM-ddTHH:mm:ss.fffffffZ\u0022;\n        public const string DefaultNumberFormat = \u0022G\u0022;\n\n        public static string ToString(bool value) =\u003E value ? \u0022true\u0022 : \u0022false\u0022;\n\n        public static string ToString(DateTime value, string format) =\u003E value.Kind switch\n        {\n            DateTimeKind.Utc =\u003E TypeFormatters.ToString(((DateTimeOffset)value), format),\n            _ =\u003E throw new NotSupportedException($\u0022DateTime {value} has a Kind of {value.Kind}. Generated clients require it to be UTC. You can call DateTime.SpecifyKind to change Kind property value to DateTimeKind.Utc.\u0022)\n        };\n\n        public static string ToString(DateTimeOffset value, string format) =\u003E format switch\n        {\n            \u0022D\u0022 =\u003E value.ToString(\u0022yyyy-MM-dd\u0022, CultureInfo.InvariantCulture),\n            \u0022U\u0022 =\u003E value.ToUnixTimeSeconds().ToString(CultureInfo.InvariantCulture),\n            \u0022O\u0022 =\u003E value.ToUniversalTime().ToString(RoundtripZFormat, CultureInfo.InvariantCulture),\n            \u0022o\u0022 =\u003E value.ToUniversalTime().ToString(RoundtripZFormat, CultureInfo.InvariantCulture),\n            \u0022R\u0022 =\u003E value.ToString(\u0022r\u0022, CultureInfo.InvariantCulture),\n            _ =\u003E value.ToString(format, CultureInfo.InvariantCulture)\n        };\n\n        public static string ToString(TimeSpan value, string format) =\u003E format switch\n        {\n            \u0022P\u0022 =\u003E XmlConvert.ToString(value),\n            _ =\u003E value.ToString(format, CultureInfo.InvariantCulture)\n        };\n\n        public static string ToString(Byte[] value, string format) =\u003E format switch\n        {\n            \u0022U\u0022 =\u003E TypeFormatters.ToBase64UrlString(value),\n            \u0022D\u0022 =\u003E Convert.ToBase64String(value),\n            _ =\u003E throw new ArgumentException($\u0022Format is not supported: \u0027{format}\u0027\u0022, nameof(format))\n        };\n\n        public static string ToBase64UrlString(Byte[] value)\n        {\n            int numWholeOrPartialInputBlocks = (checked (value.Length \u002B 2) / 3);\n            int size = checked (numWholeOrPartialInputBlocks * 4);\n            Char[] output = new char[size];\n\n            int numBase64Chars = Convert.ToBase64CharArray(value, 0, value.Length, output, 0);\n\n            int i = 0;\n            for (; (i \u003C numBase64Chars); i\u002B\u002B)\n            {\n                char ch = output[i];\n                if ((ch == \u0027\u002B\u0027))\n                {\n                    output[i] = \u0027-\u0027;\n                }\n                else\n                {\n                    if ((ch == \u0027/\u0027))\n                    {\n                        output[i] = \u0027_\u0027;\n                    }\n                    else\n                    {\n                        if ((ch == \u0027=\u0027))\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return new string(output, 0, i);\n        }\n\n        public static Byte[] FromBase64UrlString(string value)\n        {\n            int paddingCharsToAdd = (value.Length % 4) switch\n            {\n                0 =\u003E 0,\n                2 =\u003E 2,\n                3 =\u003E 1,\n                _ =\u003E throw new InvalidOperationException(\u0022Malformed input\u0022)\n            };\n            Char[] output = new char[(value.Length \u002B paddingCharsToAdd)];\n            int i = 0;\n            for (; (i \u003C value.Length); i\u002B\u002B)\n            {\n                char ch = value[i];\n                if ((ch == \u0027-\u0027))\n                {\n                    output[i] = \u0027\u002B\u0027;\n                }\n                else\n                {\n                    if ((ch == \u0027_\u0027))\n                    {\n                        output[i] = \u0027/\u0027;\n                    }\n                    else\n                    {\n                        output[i] = ch;\n                    }\n                }\n            }\n\n            for (; (i \u003C output.Length); i\u002B\u002B)\n            {\n                output[i] = \u0027=\u0027;\n            }\n\n            return Convert.FromBase64CharArray(output, 0, output.Length);\n        }\n\n        public static DateTimeOffset ParseDateTimeOffset(string value, string format) =\u003E format switch\n        {\n            \u0022U\u0022 =\u003E DateTimeOffset.FromUnixTimeSeconds(long.Parse(value, CultureInfo.InvariantCulture)),\n            _ =\u003E DateTimeOffset.Parse(value, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal)\n        };\n\n        public static TimeSpan ParseTimeSpan(string value, string format) =\u003E format switch\n        {\n            \u0022P\u0022 =\u003E XmlConvert.ToTimeSpan(value),\n            _ =\u003E TimeSpan.ParseExact(value, format, CultureInfo.InvariantCulture)\n        };\n\n        public static string ConvertToString(object value, string format = ((string)null)) =\u003E value switch\n        {\n            null =\u003E \u0022null\u0022,\n            string s =\u003E s,\n            bool b =\u003E TypeFormatters.ToString(b),\n            (int  or  (float  or  (double  or  (long  or  decimal)))) =\u003E ((IFormattable)value).ToString(DefaultNumberFormat, CultureInfo.InvariantCulture),\n            Byte[] b0 when (format != null) =\u003E TypeFormatters.ToString(b0, format),\n            IEnumerable\u003Cstring\u003E s0 =\u003E string.Join(\u0022,\u0022, s0),\n            DateTimeOffset dateTime when (format != null) =\u003E TypeFormatters.ToString(dateTime, format),\n            TimeSpan timeSpan when (format != null) =\u003E TypeFormatters.ToString(timeSpan, format),\n            TimeSpan timeSpan0 =\u003E XmlConvert.ToString(timeSpan0),\n            Guid guid =\u003E guid.ToString(),\n            BinaryData binaryData =\u003E TypeFormatters.ConvertToString(binaryData.ToArray(), format),\n            _ =\u003E value.ToString()\n        };\n    }\n}\n"
          }
        },
        {
          "name": "ClientPipelineExtensions.cs",
          "typeDeclaration": {
            "name": "ClientPipelineExtensions",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\nusing System.Threading.Tasks;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class ClientPipelineExtensions\n    {\n        public static async ValueTask\u003CPipelineResponse\u003E ProcessMessageAsync(this ClientPipeline pipeline, PipelineMessage message, RequestOptions options)\n        {\n            await pipeline.SendAsync(message).ConfigureAwait(false);\n\n            if ((message.Response.IsError \u0026\u0026 ((options?.ErrorOptions \u0026 ClientErrorBehaviors.NoThrow) != ClientErrorBehaviors.NoThrow)))\n            {\n                throw await ClientResultException.CreateAsync(message.Response).ConfigureAwait(false);\n            }\n\n            PipelineResponse response = message.BufferResponse ? message.Response : ExtractResponseContent(message);\n            return response;\n        }\n\n        public static PipelineResponse ProcessMessage(this ClientPipeline pipeline, PipelineMessage message, RequestOptions options)\n        {\n            pipeline.Send(message);\n\n            if ((message.Response.IsError \u0026\u0026 ((options?.ErrorOptions \u0026 ClientErrorBehaviors.NoThrow) != ClientErrorBehaviors.NoThrow)))\n            {\n                throw new ClientResultException(message.Response);\n            }\n\n            PipelineResponse response = message.BufferResponse ? message.Response : ExtractResponseContent(message);\n            return response;\n        }\n\n        public static async ValueTask\u003CClientResult\u003Cbool\u003E\u003E ProcessHeadAsBoolMessageAsync(this ClientPipeline pipeline, PipelineMessage message, RequestOptions options)\n        {\n            PipelineResponse response = await pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false);\n            switch (response.Status)\n            {\n                case ((\u003E= 200) and (\u003C 300)):\n                    return ClientResult.FromValue\u003Cbool\u003E(true, response);\n                case ((\u003E= 400) and (\u003C 500)):\n                    return ClientResult.FromValue\u003Cbool\u003E(false, response);\n                default:\n                    return new ErrorResult\u003Cbool\u003E(response, new ClientResultException(response));\n            }\n        }\n\n        public static ClientResult\u003Cbool\u003E ProcessHeadAsBoolMessage(this ClientPipeline pipeline, PipelineMessage message, RequestOptions options)\n        {\n            PipelineResponse response = pipeline.ProcessMessage(message, options);\n            switch (response.Status)\n            {\n                case ((\u003E= 200) and (\u003C 300)):\n                    return ClientResult.FromValue\u003Cbool\u003E(true, response);\n                case ((\u003E= 400) and (\u003C 500)):\n                    return ClientResult.FromValue\u003Cbool\u003E(false, response);\n                default:\n                    return new ErrorResult\u003Cbool\u003E(response, new ClientResultException(response));\n            }\n        }\n\n        private static PipelineResponse ExtractResponseContent(PipelineMessage message)\n        {\n            return message.ExtractResponse();\n        }\n    }\n}\n"
          }
        },
        {
          "name": "ErrorResult.cs",
          "typeDeclaration": {
            "name": "ErrorResult",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\n\nnamespace UnbrandedTypeSpec\n{\n    internal partial class ErrorResult\u003CT\u003E : ClientResult\u003CT\u003E\n    {\n        private readonly PipelineResponse _response;\n        private readonly ClientResultException _exception;\n\n        public ErrorResult(PipelineResponse response, ClientResultException exception) : base(default, response)\n        {\n            _response = response;\n            _exception = exception;\n        }\n\n        public override T Value =\u003E throw _exception;\n    }\n}\n"
          }
        },
        {
          "name": "ClientUriBuilder.cs",
          "typeDeclaration": {
            "name": "ClientUriBuilder",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace UnbrandedTypeSpec\n{\n    internal partial class ClientUriBuilder\n    {\n        private UriBuilder _uriBuilder;\n        private StringBuilder _pathBuilder;\n        private StringBuilder _queryBuilder;\n\n        public ClientUriBuilder()\n        {\n        }\n\n        private UriBuilder UriBuilder =\u003E (_uriBuilder  ??=  new UriBuilder());\n\n        private StringBuilder PathBuilder =\u003E (_pathBuilder  ??=  new StringBuilder(UriBuilder.Path));\n\n        private StringBuilder QueryBuilder =\u003E (_queryBuilder  ??=  new StringBuilder(UriBuilder.Query));\n\n        public void Reset(Uri uri)\n        {\n            _uriBuilder = new UriBuilder(uri);\n            _pathBuilder = new StringBuilder(UriBuilder.Path);\n            _queryBuilder = new StringBuilder(UriBuilder.Query);\n        }\n\n        public void AppendPath(string value, bool escape)\n        {\n            if (escape)\n            {\n                value = Uri.EscapeDataString(value);\n            }\n            if ((((PathBuilder.Length \u003E 0) \u0026\u0026 (PathBuilder[(PathBuilder.Length - 1)] == \u0027/\u0027)) \u0026\u0026 (value[0] == \u0027/\u0027)))\n            {\n                PathBuilder.Remove((PathBuilder.Length - 1), 1);\n            }\n            PathBuilder.Append(value);\n            UriBuilder.Path = PathBuilder.ToString();\n        }\n\n        public void AppendPath(bool value, bool escape = false) =\u003E AppendPath(TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendPath(float value, bool escape = true) =\u003E AppendPath(TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendPath(double value, bool escape = true) =\u003E AppendPath(TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendPath(int value, bool escape = true) =\u003E AppendPath(TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendPath(Byte[] value, string format, bool escape = true) =\u003E AppendPath(TypeFormatters.ConvertToString(value, format), escape);\n\n        public void AppendPath(IEnumerable\u003Cstring\u003E value, bool escape = true) =\u003E AppendPath(TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendPath(DateTimeOffset value, string format, bool escape = true) =\u003E AppendPath(TypeFormatters.ConvertToString(value, format), escape);\n\n        public void AppendPath(TimeSpan value, string format, bool escape = true) =\u003E AppendPath(TypeFormatters.ConvertToString(value, format), escape);\n\n        public void AppendPath(Guid value, bool escape = true) =\u003E AppendPath(TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendPath(long value, bool escape = true) =\u003E AppendPath(TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, string value, bool escape)\n        {\n            if ((QueryBuilder.Length \u003E 0))\n            {\n                QueryBuilder.Append(\u0027\u0026\u0027);\n            }\n            if (escape)\n            {\n                value = Uri.EscapeDataString(value);\n            }\n            QueryBuilder.Append(name);\n            QueryBuilder.Append(\u0027=\u0027);\n            QueryBuilder.Append(value);\n        }\n\n        public void AppendQuery(string name, bool value, bool escape = false) =\u003E AppendQuery(name, TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, float value, bool escape = true) =\u003E AppendQuery(name, TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, DateTimeOffset value, string format, bool escape = true) =\u003E AppendQuery(name, TypeFormatters.ConvertToString(value, format), escape);\n\n        public void AppendQuery(string name, TimeSpan value, string format, bool escape = true) =\u003E AppendQuery(name, TypeFormatters.ConvertToString(value, format), escape);\n\n        public void AppendQuery(string name, double value, bool escape = true) =\u003E AppendQuery(name, TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, decimal value, bool escape = true) =\u003E AppendQuery(name, TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, int value, bool escape = true) =\u003E AppendQuery(name, TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, long value, bool escape = true) =\u003E AppendQuery(name, TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, TimeSpan value, bool escape = true) =\u003E AppendQuery(name, TypeFormatters.ConvertToString(value), escape);\n\n        public void AppendQuery(string name, Byte[] value, string format, bool escape = true) =\u003E AppendQuery(name, TypeFormatters.ConvertToString(value, format), escape);\n\n        public void AppendQuery(string name, Guid value, bool escape = true) =\u003E AppendQuery(name, TypeFormatters.ConvertToString(value), escape);\n\n        public Uri ToUri()\n        {\n            if ((_pathBuilder != null))\n            {\n                UriBuilder.Path = _pathBuilder.ToString();\n            }\n            if ((_queryBuilder != null))\n            {\n                UriBuilder.Query = _queryBuilder.ToString();\n            }\n            return UriBuilder.Uri;\n        }\n\n        public void AppendQueryDelimited\u003CT\u003E(string name, IEnumerable\u003CT\u003E value, string delimiter, bool escape = true)\n        {\n            IEnumerable\u003Cstring\u003E stringValues = value.Select(v =\u003E TypeFormatters.ConvertToString(v));\n            AppendQuery(name, string.Join(delimiter, stringValues), escape);\n        }\n\n        public void AppendQueryDelimited\u003CT\u003E(string name, IEnumerable\u003CT\u003E value, string delimiter, string format, bool escape = true)\n        {\n            IEnumerable\u003Cstring\u003E stringValues = value.Select(v =\u003E TypeFormatters.ConvertToString(v, format));\n            AppendQuery(name, string.Join(delimiter, stringValues), escape);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "Utf8JsonBinaryContent.cs",
          "typeDeclaration": {
            "name": "Utf8JsonBinaryContent",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System.ClientModel;\nusing System.IO;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace UnbrandedTypeSpec\n{\n    internal partial class Utf8JsonBinaryContent : BinaryContent\n    {\n        private readonly MemoryStream _stream;\n        private readonly BinaryContent _content;\n\n        public Utf8JsonBinaryContent()\n        {\n            _stream = new MemoryStream();\n            _content = BinaryContent.Create(_stream);\n            JsonWriter = new Utf8JsonWriter(_stream);\n        }\n\n        public Utf8JsonWriter JsonWriter { get; }\n\n        public override async Task WriteToAsync(Stream stream, CancellationToken cancellationToken = default)\n        {\n            await JsonWriter.FlushAsync().ConfigureAwait(false);\n            await _content.WriteToAsync(stream, cancellationToken).ConfigureAwait(false);\n        }\n\n        public override void WriteTo(Stream stream, CancellationToken cancellationToken = default)\n        {\n            JsonWriter.Flush();\n            _content.WriteTo(stream, cancellationToken);\n        }\n\n        public override bool TryComputeLength(out long length)\n        {\n            length = (JsonWriter.BytesCommitted \u002B JsonWriter.BytesPending);\n            return true;\n        }\n\n        public override void Dispose()\n        {\n            JsonWriter.Dispose();\n            _content.Dispose();\n            _stream.Dispose();\n        }\n    }\n}\n"
          }
        },
        {
          "name": "BinaryContentHelper.cs",
          "typeDeclaration": {
            "name": "BinaryContentHelper",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel;\nusing System.Collections.Generic;\nusing System.Text.Json;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class BinaryContentHelper\n    {\n        public static BinaryContent FromEnumerable\u003CT\u003E(IEnumerable\u003CT\u003E enumerable)\n            where T : notnull \n        {\n            Utf8JsonBinaryContent content = new Utf8JsonBinaryContent();\n            content.JsonWriter.WriteStartArray();\n            foreach (var item in enumerable)\n            {\n                content.JsonWriter.WriteObjectValue\u003CT\u003E(item, ModelSerializationExtensions.WireOptions);\n            }\n            content.JsonWriter.WriteEndArray();\n\n            return content;\n        }\n\n        public static BinaryContent FromEnumerable(IEnumerable\u003CBinaryData\u003E enumerable)\n        {\n            Utf8JsonBinaryContent content = new Utf8JsonBinaryContent();\n            content.JsonWriter.WriteStartArray();\n            foreach (var item in enumerable)\n            {\n                if ((item == null))\n                {\n                    content.JsonWriter.WriteNullValue();\n                }\n                else\n                {\n#if NET6_0_OR_GREATER\n                    content.JsonWriter.WriteRawValue(item);\n#else\n                    using (JsonDocument document = JsonDocument.Parse(item))\n                    {\n                        JsonSerializer.Serialize(content.JsonWriter, document.RootElement);\n                    }\n#endif\n                }\n            }\n            content.JsonWriter.WriteEndArray();\n\n            return content;\n        }\n\n        public static BinaryContent FromEnumerable\u003CT\u003E(ReadOnlySpan\u003CT\u003E span)\n            where T : notnull \n        {\n            Utf8JsonBinaryContent content = new Utf8JsonBinaryContent();\n            content.JsonWriter.WriteStartArray();\n            int i = 0;\n            for (; (i \u003C span.Length); i\u002B\u002B)\n            {\n                content.JsonWriter.WriteObjectValue\u003CT\u003E(span[i], ModelSerializationExtensions.WireOptions);\n            }\n            content.JsonWriter.WriteEndArray();\n\n            return content;\n        }\n\n        public static BinaryContent FromDictionary\u003CTValue\u003E(IDictionary\u003Cstring, TValue\u003E dictionary)\n            where TValue : notnull \n        {\n            Utf8JsonBinaryContent content = new Utf8JsonBinaryContent();\n            content.JsonWriter.WriteStartObject();\n            foreach (var item in dictionary)\n            {\n                content.JsonWriter.WritePropertyName(item.Key);\n                content.JsonWriter.WriteObjectValue\u003CTValue\u003E(item.Value, ModelSerializationExtensions.WireOptions);\n            }\n            content.JsonWriter.WriteEndObject();\n\n            return content;\n        }\n\n        public static BinaryContent FromDictionary(IDictionary\u003Cstring, BinaryData\u003E dictionary)\n        {\n            Utf8JsonBinaryContent content = new Utf8JsonBinaryContent();\n            content.JsonWriter.WriteStartObject();\n            foreach (var item in dictionary)\n            {\n                content.JsonWriter.WritePropertyName(item.Key);\n                if ((item.Value == null))\n                {\n                    content.JsonWriter.WriteNullValue();\n                }\n                else\n                {\n#if NET6_0_OR_GREATER\n                    content.JsonWriter.WriteRawValue(item.Value);\n#else\n                    using (JsonDocument document = JsonDocument.Parse(item.Value))\n                    {\n                        JsonSerializer.Serialize(content.JsonWriter, document.RootElement);\n                    }\n#endif\n                }\n            }\n            content.JsonWriter.WriteEndObject();\n\n            return content;\n        }\n\n        public static BinaryContent FromObject(object value)\n        {\n            Utf8JsonBinaryContent content = new Utf8JsonBinaryContent();\n            content.JsonWriter.WriteObjectValue\u003Cobject\u003E(value, ModelSerializationExtensions.WireOptions);\n            return content;\n        }\n\n        public static BinaryContent FromObject(BinaryData value)\n        {\n            Utf8JsonBinaryContent content = new Utf8JsonBinaryContent();\n#if NET6_0_OR_GREATER\n            content.JsonWriter.WriteRawValue(value);\n#else\n            using (JsonDocument document = JsonDocument.Parse(value))\n            {\n                JsonSerializer.Serialize(content.JsonWriter, document.RootElement);\n            }\n#endif\n            return content;\n        }\n    }\n}\n"
          }
        },
        {
          "name": "PipelineRequestHeadersExtensions.cs",
          "typeDeclaration": {
            "name": "PipelineRequestHeadersExtensions",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace UnbrandedTypeSpec\n{\n    internal static partial class PipelineRequestHeadersExtensions\n    {\n        public static void SetDelimited\u003CT\u003E(this PipelineRequestHeaders headers, string name, IEnumerable\u003CT\u003E value, string delimiter)\n        {\n            IEnumerable\u003Cstring\u003E stringValues = value.Select(v =\u003E TypeFormatters.ConvertToString(v));\n            headers.Set(name, string.Join(delimiter, stringValues));\n        }\n\n        public static void SetDelimited\u003CT\u003E(this PipelineRequestHeaders headers, string name, IEnumerable\u003CT\u003E value, string delimiter, string format)\n        {\n            IEnumerable\u003Cstring\u003E stringValues = value.Select(v =\u003E TypeFormatters.ConvertToString(v, format));\n            headers.Set(name, string.Join(delimiter, stringValues));\n        }\n    }\n}\n"
          }
        }
      ]
    },
    {
      "name": "./src/Generated",
      "files": [
        {
          "name": "UnbrandedTypeSpecModelFactory.cs",
          "typeDeclaration": {
            "name": "UnbrandedTypeSpecModelFactory",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing UnbrandedTypeSpec;\n\nnamespace UnbrandedTypeSpec.Models\n{\n    /// \u003Csummary\u003E A factory class for creating instances of the models for mocking. \u003C/summary\u003E\n    public static partial class UnbrandedTypeSpecModelFactory\n    {\n        /// \u003Csummary\u003E A model with a few properties of literal types. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the Thing. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredUnion\u0022\u003E required Union. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralString\u0022\u003E required literal string. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralInt\u0022\u003E required literal int. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralFloat\u0022\u003E required literal float. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralBool\u0022\u003E required literal bool. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralString\u0022\u003E optional literal string. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralInt\u0022\u003E optional literal int. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralFloat\u0022\u003E optional literal float. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralBool\u0022\u003E optional literal bool. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredBadDescription\u0022\u003E description with xml \u0026lt;|endoftext|\u0026gt;. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalNullableList\u0022\u003E optional nullable collection. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredNullableList\u0022\u003E required nullable collection. \u003C/param\u003E\n        /// \u003Creturns\u003E A new \u003Csee cref=\u0022Thing\u0022/\u003E instance for mocking. \u003C/returns\u003E\n        public static Thing Thing(string name = default, BinaryData requiredUnion = default, ThingRequiredLiteralString requiredLiteralString = default, ThingRequiredLiteralInt requiredLiteralInt = default, ThingRequiredLiteralFloat requiredLiteralFloat = default, bool requiredLiteralBool = default, ThingOptionalLiteralString? optionalLiteralString = default, ThingOptionalLiteralInt? optionalLiteralInt = default, ThingOptionalLiteralFloat? optionalLiteralFloat = default, bool? optionalLiteralBool = default, string requiredBadDescription = default, IEnumerable\u003Cint\u003E optionalNullableList = default, IEnumerable\u003Cint\u003E requiredNullableList = default)\n        {\n            optionalNullableList ??= new ChangeTrackingList\u003Cint\u003E();\n            requiredNullableList ??= new ChangeTrackingList\u003Cint\u003E();\n\n            return new Thing(\n                name,\n                requiredUnion,\n                requiredLiteralString,\n                requiredLiteralInt,\n                requiredLiteralFloat,\n                requiredLiteralBool,\n                optionalLiteralString,\n                optionalLiteralInt,\n                optionalLiteralFloat,\n                optionalLiteralBool,\n                requiredBadDescription,\n                optionalNullableList?.ToList(),\n                requiredNullableList?.ToList(),\n                additionalBinaryDataProperties: null);\n        }\n\n        /// \u003Csummary\u003E this is a roundtrip model. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022requiredString\u0022\u003E Required string, illustrating a reference type property. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredInt\u0022\u003E Required int, illustrating a value type property. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredCollection\u0022\u003E Required collection of enums. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredDictionary\u0022\u003E Required dictionary of enums. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredModel\u0022\u003E Required model. \u003C/param\u003E\n        /// \u003Cparam name=\u0022intExtensibleEnum\u0022\u003E this is an int based extensible enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022intExtensibleEnumCollection\u0022\u003E this is a collection of int based extensible enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022floatExtensibleEnum\u0022\u003E this is a float based extensible enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022floatExtensibleEnumWithIntValue\u0022\u003E this is a float based extensible enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022floatExtensibleEnumCollection\u0022\u003E this is a collection of float based extensible enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022floatFixedEnum\u0022\u003E this is a float based fixed enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022floatFixedEnumWithIntValue\u0022\u003E this is a float based fixed enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022floatFixedEnumCollection\u0022\u003E this is a collection of float based fixed enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022intFixedEnum\u0022\u003E this is a int based fixed enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022intFixedEnumCollection\u0022\u003E this is a collection of int based fixed enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022stringFixedEnum\u0022\u003E this is a string based fixed enum. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredUnknown\u0022\u003E required unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalUnknown\u0022\u003E optional unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredRecordUnknown\u0022\u003E required record of unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalRecordUnknown\u0022\u003E optional record of unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022readOnlyRequiredRecordUnknown\u0022\u003E required readonly record of unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022readOnlyOptionalRecordUnknown\u0022\u003E optional readonly record of unknown. \u003C/param\u003E\n        /// \u003Cparam name=\u0022modelWithRequiredNullable\u0022\u003E this is a model with required nullable properties. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredBytes\u0022\u003E Required bytes. \u003C/param\u003E\n        /// \u003Creturns\u003E A new \u003Csee cref=\u0022RoundTripModel\u0022/\u003E instance for mocking. \u003C/returns\u003E\n        public static RoundTripModel RoundTripModel(string requiredString = default, int requiredInt = default, IEnumerable\u003CStringFixedEnum\u003E requiredCollection = default, IDictionary\u003Cstring, StringExtensibleEnum\u003E requiredDictionary = default, Thing requiredModel = default, IntExtensibleEnum? intExtensibleEnum = default, IEnumerable\u003CIntExtensibleEnum\u003E intExtensibleEnumCollection = default, FloatExtensibleEnum? floatExtensibleEnum = default, FloatExtensibleEnumWithIntValue? floatExtensibleEnumWithIntValue = default, IEnumerable\u003CFloatExtensibleEnum\u003E floatExtensibleEnumCollection = default, FloatFixedEnum? floatFixedEnum = default, FloatFixedEnumWithIntValue? floatFixedEnumWithIntValue = default, IEnumerable\u003CFloatFixedEnum\u003E floatFixedEnumCollection = default, IntFixedEnum? intFixedEnum = default, IEnumerable\u003CIntFixedEnum\u003E intFixedEnumCollection = default, StringFixedEnum? stringFixedEnum = default, BinaryData requiredUnknown = default, BinaryData optionalUnknown = default, IDictionary\u003Cstring, BinaryData\u003E requiredRecordUnknown = default, IDictionary\u003Cstring, BinaryData\u003E optionalRecordUnknown = default, IReadOnlyDictionary\u003Cstring, BinaryData\u003E readOnlyRequiredRecordUnknown = default, IReadOnlyDictionary\u003Cstring, BinaryData\u003E readOnlyOptionalRecordUnknown = default, ModelWithRequiredNullableProperties modelWithRequiredNullable = default, BinaryData requiredBytes = default)\n        {\n            requiredCollection ??= new ChangeTrackingList\u003CStringFixedEnum\u003E();\n            requiredDictionary ??= new ChangeTrackingDictionary\u003Cstring, StringExtensibleEnum\u003E();\n            intExtensibleEnumCollection ??= new ChangeTrackingList\u003CIntExtensibleEnum\u003E();\n            floatExtensibleEnumCollection ??= new ChangeTrackingList\u003CFloatExtensibleEnum\u003E();\n            floatFixedEnumCollection ??= new ChangeTrackingList\u003CFloatFixedEnum\u003E();\n            intFixedEnumCollection ??= new ChangeTrackingList\u003CIntFixedEnum\u003E();\n            requiredRecordUnknown ??= new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n            optionalRecordUnknown ??= new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n            readOnlyRequiredRecordUnknown ??= new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n            readOnlyOptionalRecordUnknown ??= new ChangeTrackingDictionary\u003Cstring, BinaryData\u003E();\n\n            return new RoundTripModel(\n                requiredString,\n                requiredInt,\n                requiredCollection?.ToList(),\n                requiredDictionary,\n                requiredModel,\n                intExtensibleEnum,\n                intExtensibleEnumCollection?.ToList(),\n                floatExtensibleEnum,\n                floatExtensibleEnumWithIntValue,\n                floatExtensibleEnumCollection?.ToList(),\n                floatFixedEnum,\n                floatFixedEnumWithIntValue,\n                floatFixedEnumCollection?.ToList(),\n                intFixedEnum,\n                intFixedEnumCollection?.ToList(),\n                stringFixedEnum,\n                requiredUnknown,\n                optionalUnknown,\n                requiredRecordUnknown,\n                optionalRecordUnknown,\n                readOnlyRequiredRecordUnknown,\n                readOnlyOptionalRecordUnknown,\n                modelWithRequiredNullable,\n                requiredBytes,\n                additionalBinaryDataProperties: null);\n        }\n\n        /// \u003Csummary\u003E A model with a few required nullable properties. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022requiredNullablePrimitive\u0022\u003E required nullable primitive type. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredExtensibleEnum\u0022\u003E required nullable extensible enum type. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredFixedEnum\u0022\u003E required nullable fixed enum type. \u003C/param\u003E\n        /// \u003Creturns\u003E A new \u003Csee cref=\u0022ModelWithRequiredNullableProperties\u0022/\u003E instance for mocking. \u003C/returns\u003E\n        public static ModelWithRequiredNullableProperties ModelWithRequiredNullableProperties(int? requiredNullablePrimitive = default, StringExtensibleEnum? requiredExtensibleEnum = default, StringFixedEnum? requiredFixedEnum = default)\n        {\n\n            return new ModelWithRequiredNullableProperties(requiredNullablePrimitive, requiredExtensibleEnum, requiredFixedEnum, additionalBinaryDataProperties: null);\n        }\n\n        /// \u003Csummary\u003E this is not a friendly model but with a friendly name. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the NotFriend. \u003C/param\u003E\n        /// \u003Creturns\u003E A new \u003Csee cref=\u0022Friend\u0022/\u003E instance for mocking. \u003C/returns\u003E\n        public static Friend Friend(string name = default)\n        {\n\n            return new Friend(name, additionalBinaryDataProperties: null);\n        }\n\n        /// \u003Csummary\u003E this is a model with a projected name. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the ModelWithProjectedName. \u003C/param\u003E\n        /// \u003Creturns\u003E A new \u003Csee cref=\u0022ProjectedModel\u0022/\u003E instance for mocking. \u003C/returns\u003E\n        public static ProjectedModel ProjectedModel(string name = default)\n        {\n\n            return new ProjectedModel(name, additionalBinaryDataProperties: null);\n        }\n\n        /// \u003Csummary\u003E The ReturnsAnonymousModelResponse. \u003C/summary\u003E\n        /// \u003Creturns\u003E A new \u003Csee cref=\u0022ReturnsAnonymousModelResponse\u0022/\u003E instance for mocking. \u003C/returns\u003E\n        public static ReturnsAnonymousModelResponse ReturnsAnonymousModelResponse()\n        {\n\n            return new ReturnsAnonymousModelResponse(additionalBinaryDataProperties: null);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "UnbrandedTypeSpecClient.cs",
          "typeDeclaration": {
            "name": "UnbrandedTypeSpecClient",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing UnbrandedTypeSpec.Models;\n\nnamespace UnbrandedTypeSpec\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public partial class UnbrandedTypeSpecClient\n    {\n        private readonly Uri _endpoint;\n        private const string AuthorizationHeader = \u0022my-api-key\u0022;\n        /// \u003Csummary\u003E A credential used to authenticate to the service. \u003C/summary\u003E\n        private readonly ApiKeyCredential _keyCredential;\n        private readonly string _apiVersion;\n\n        /// \u003Csummary\u003E Initializes a new instance of UnbrandedTypeSpecClient for mocking. \u003C/summary\u003E\n        protected UnbrandedTypeSpecClient()\n        {\n        }\n\n        /// \u003Csummary\u003E Initializes a new instance of UnbrandedTypeSpecClient. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022endpoint\u0022\u003E Service endpoint. \u003C/param\u003E\n        /// \u003Cparam name=\u0022keyCredential\u0022\u003E A credential used to authenticate to the service. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022endpoint\u0022/\u003E or \u003Cparamref name=\u0022keyCredential\u0022/\u003E is null. \u003C/exception\u003E\n        public UnbrandedTypeSpecClient(Uri endpoint, ApiKeyCredential keyCredential) : this(endpoint, keyCredential, new UnbrandedTypeSpecClientOptions())\n        {\n        }\n\n        /// \u003Csummary\u003E Initializes a new instance of UnbrandedTypeSpecClient. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022endpoint\u0022\u003E Service endpoint. \u003C/param\u003E\n        /// \u003Cparam name=\u0022keyCredential\u0022\u003E A credential used to authenticate to the service. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The options for configuring the client. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022endpoint\u0022/\u003E or \u003Cparamref name=\u0022keyCredential\u0022/\u003E is null. \u003C/exception\u003E\n        public UnbrandedTypeSpecClient(Uri endpoint, ApiKeyCredential keyCredential, UnbrandedTypeSpecClientOptions options)\n        {\n            Argument.AssertNotNull(endpoint, nameof(endpoint));\n            Argument.AssertNotNull(keyCredential, nameof(keyCredential));\n\n            options ??= new UnbrandedTypeSpecClientOptions();\n\n            _endpoint = endpoint;\n            _keyCredential = keyCredential;\n            Pipeline = ClientPipeline.Create(options, Array.Empty\u003CPipelinePolicy\u003E(), new PipelinePolicy[] { ApiKeyAuthenticationPolicy.CreateHeaderApiKeyPolicy(_keyCredential, AuthorizationHeader) }, Array.Empty\u003CPipelinePolicy\u003E());\n            _apiVersion = options.Version;\n        }\n\n        /// \u003Csummary\u003E The HTTP pipeline for sending and receiving REST requests and responses. \u003C/summary\u003E\n        public ClientPipeline Pipeline { get; }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022headParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022queryParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalQuery\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022headParameter\u0022/\u003E or \u003Cparamref name=\u0022queryParameter\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult SayHi(string headParameter, string queryParameter, string optionalQuery, RequestOptions options)\n        {\n            Argument.AssertNotNull(headParameter, nameof(headParameter));\n            Argument.AssertNotNull(queryParameter, nameof(queryParameter));\n\n            using PipelineMessage message = this.CreateSayHiRequest(headParameter, queryParameter, optionalQuery, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022headParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022queryParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalQuery\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022headParameter\u0022/\u003E or \u003Cparamref name=\u0022queryParameter\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E SayHiAsync(string headParameter, string queryParameter, string optionalQuery, RequestOptions options)\n        {\n            Argument.AssertNotNull(headParameter, nameof(headParameter));\n            Argument.AssertNotNull(queryParameter, nameof(queryParameter));\n\n            using PipelineMessage message = this.CreateSayHiRequest(headParameter, queryParameter, optionalQuery, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Return hi. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022headParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022queryParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalQuery\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022headParameter\u0022/\u003E or \u003Cparamref name=\u0022queryParameter\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult\u003CThing\u003E SayHi(string headParameter, string queryParameter, string optionalQuery)\n        {\n            Argument.AssertNotNull(headParameter, nameof(headParameter));\n            Argument.AssertNotNull(queryParameter, nameof(queryParameter));\n\n            ClientResult result = this.SayHi(headParameter, queryParameter, optionalQuery, null);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Return hi. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022headParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022queryParameter\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalQuery\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022headParameter\u0022/\u003E or \u003Cparamref name=\u0022queryParameter\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003CThing\u003E\u003E SayHiAsync(string headParameter, string queryParameter, string optionalQuery)\n        {\n            Argument.AssertNotNull(headParameter, nameof(headParameter));\n            Argument.AssertNotNull(queryParameter, nameof(queryParameter));\n\n            ClientResult result = await this.SayHiAsync(headParameter, queryParameter, optionalQuery, null).ConfigureAwait(false);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi again\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p2\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p2\u0022/\u003E, \u003Cparamref name=\u0022p1\u0022/\u003E or \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult HelloAgain(string p2, string p1, BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(p2, nameof(p2));\n            Argument.AssertNotNull(p1, nameof(p1));\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateHelloAgainRequest(p2, p1, content, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi again\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p2\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p2\u0022/\u003E, \u003Cparamref name=\u0022p1\u0022/\u003E or \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E HelloAgainAsync(string p2, string p1, BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(p2, nameof(p2));\n            Argument.AssertNotNull(p1, nameof(p1));\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateHelloAgainRequest(p2, p1, content, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Return hi again. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p2\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022action\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p2\u0022/\u003E, \u003Cparamref name=\u0022p1\u0022/\u003E or \u003Cparamref name=\u0022action\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult\u003CRoundTripModel\u003E HelloAgain(string p2, string p1, RoundTripModel action)\n        {\n            Argument.AssertNotNull(p2, nameof(p2));\n            Argument.AssertNotNull(p1, nameof(p1));\n            Argument.AssertNotNull(action, nameof(action));\n\n            ClientResult result = this.HelloAgain(p2, p1, action, null);\n            return ClientResult.FromValue(((RoundTripModel)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Return hi again. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p2\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022action\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p2\u0022/\u003E, \u003Cparamref name=\u0022p1\u0022/\u003E or \u003Cparamref name=\u0022action\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003CRoundTripModel\u003E\u003E HelloAgainAsync(string p2, string p1, RoundTripModel action)\n        {\n            Argument.AssertNotNull(p2, nameof(p2));\n            Argument.AssertNotNull(p1, nameof(p1));\n            Argument.AssertNotNull(action, nameof(action));\n\n            ClientResult result = await this.HelloAgainAsync(p2, p1, action, null).ConfigureAwait(false);\n            return ClientResult.FromValue(((RoundTripModel)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi again\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p2\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p2\u0022/\u003E, \u003Cparamref name=\u0022p1\u0022/\u003E or \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult NoContentType(string p2, string p1, BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(p2, nameof(p2));\n            Argument.AssertNotNull(p1, nameof(p1));\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateNoContentTypeRequest(p2, p1, content, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi again\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p2\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p2\u0022/\u003E, \u003Cparamref name=\u0022p1\u0022/\u003E or \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E NoContentTypeAsync(string p2, string p1, BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(p2, nameof(p2));\n            Argument.AssertNotNull(p1, nameof(p1));\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateNoContentTypeRequest(p2, p1, content, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi in demo2\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult HelloDemo2(RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateHelloDemo2Request(options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi in demo2\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E HelloDemo2Async(RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateHelloDemo2Request(options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Return hi in demo2. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult\u003CThing\u003E HelloDemo2()\n        {\n            ClientResult result = this.HelloDemo2(null);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Return hi in demo2. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003CThing\u003E\u003E HelloDemo2Async()\n        {\n            ClientResult result = await this.HelloDemo2Async(null).ConfigureAwait(false);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Create with literal value\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult CreateLiteral(BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateCreateLiteralRequest(content, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Create with literal value\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E CreateLiteralAsync(BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateCreateLiteralRequest(content, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Create with literal value. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022body\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022body\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult\u003CThing\u003E CreateLiteral(Thing body)\n        {\n            Argument.AssertNotNull(body, nameof(body));\n\n            ClientResult result = this.CreateLiteral(body, null);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Create with literal value. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022body\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022body\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003CThing\u003E\u003E CreateLiteralAsync(Thing body)\n        {\n            Argument.AssertNotNull(body, nameof(body));\n\n            ClientResult result = await this.CreateLiteralAsync(body, null).ConfigureAwait(false);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Send literal parameters\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult HelloLiteral(RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateHelloLiteralRequest(options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Send literal parameters\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E HelloLiteralAsync(RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateHelloLiteralRequest(options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Send literal parameters. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult\u003CThing\u003E HelloLiteral()\n        {\n            ClientResult result = this.HelloLiteral(null);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Send literal parameters. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003CThing\u003E\u003E HelloLiteralAsync()\n        {\n            ClientResult result = await this.HelloLiteralAsync(null).ConfigureAwait(false);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] top level method\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022action\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult TopAction(DateTimeOffset action, RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateTopActionRequest(action, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] top level method\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022action\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E TopActionAsync(DateTimeOffset action, RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateTopActionRequest(action, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E top level method. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022action\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult\u003CThing\u003E TopAction(DateTimeOffset action)\n        {\n            ClientResult result = this.TopAction(action, null);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E top level method. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022action\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003CThing\u003E\u003E TopActionAsync(DateTimeOffset action)\n        {\n            ClientResult result = await this.TopActionAsync(action, null).ConfigureAwait(false);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] top level method2\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult TopAction2(RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateTopAction2Request(options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] top level method2\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E TopAction2Async(RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateTopAction2Request(options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] top level patch\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult PatchAction(BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreatePatchActionRequest(content, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] top level patch\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E PatchActionAsync(BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreatePatchActionRequest(content, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] body parameter without body decorator\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult AnonymousBody(BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateAnonymousBodyRequest(content, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] body parameter without body decorator\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E AnonymousBodyAsync(BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateAnonymousBodyRequest(content, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E body parameter without body decorator. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the Thing. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredUnion\u0022\u003E required Union. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralString\u0022\u003E required literal string. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralInt\u0022\u003E required literal int. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralFloat\u0022\u003E required literal float. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralBool\u0022\u003E required literal bool. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredBadDescription\u0022\u003E description with xml \u0026lt;|endoftext|\u0026gt;. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredNullableList\u0022\u003E required nullable collection. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralString\u0022\u003E optional literal string. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralInt\u0022\u003E optional literal int. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralFloat\u0022\u003E optional literal float. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralBool\u0022\u003E optional literal bool. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalNullableList\u0022\u003E optional nullable collection. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E, \u003Cparamref name=\u0022requiredUnion\u0022/\u003E or \u003Cparamref name=\u0022requiredBadDescription\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult\u003CThing\u003E AnonymousBody(string name, BinaryData requiredUnion, ThingRequiredLiteralString requiredLiteralString, ThingRequiredLiteralInt requiredLiteralInt, ThingRequiredLiteralFloat requiredLiteralFloat, bool requiredLiteralBool, string requiredBadDescription, IEnumerable\u003Cint\u003E requiredNullableList, ThingOptionalLiteralString? optionalLiteralString = default, ThingOptionalLiteralInt? optionalLiteralInt = default, ThingOptionalLiteralFloat? optionalLiteralFloat = default, bool? optionalLiteralBool = default, IEnumerable\u003Cint\u003E optionalNullableList = default)\n        {\n            Argument.AssertNotNull(name, nameof(name));\n            Argument.AssertNotNull(requiredUnion, nameof(requiredUnion));\n            Argument.AssertNotNull(requiredBadDescription, nameof(requiredBadDescription));\n\n            Thing spreadModel = new Thing(\n                name,\n                requiredUnion,\n                requiredLiteralString,\n                requiredLiteralInt,\n                requiredLiteralFloat,\n                requiredLiteralBool,\n                optionalLiteralString,\n                optionalLiteralInt,\n                optionalLiteralFloat,\n                optionalLiteralBool,\n                requiredBadDescription,\n                (optionalNullableList?.ToList() as IList\u003Cint\u003E ?? new ChangeTrackingList\u003Cint\u003E()),\n                (requiredNullableList?.ToList() as IList\u003Cint\u003E ?? new ChangeTrackingList\u003Cint\u003E()),\n                null);\n            ClientResult result = this.AnonymousBody(spreadModel, null);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E body parameter without body decorator. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the Thing. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredUnion\u0022\u003E required Union. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralString\u0022\u003E required literal string. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralInt\u0022\u003E required literal int. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralFloat\u0022\u003E required literal float. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredLiteralBool\u0022\u003E required literal bool. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredBadDescription\u0022\u003E description with xml \u0026lt;|endoftext|\u0026gt;. \u003C/param\u003E\n        /// \u003Cparam name=\u0022requiredNullableList\u0022\u003E required nullable collection. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralString\u0022\u003E optional literal string. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralInt\u0022\u003E optional literal int. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralFloat\u0022\u003E optional literal float. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalLiteralBool\u0022\u003E optional literal bool. \u003C/param\u003E\n        /// \u003Cparam name=\u0022optionalNullableList\u0022\u003E optional nullable collection. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E, \u003Cparamref name=\u0022requiredUnion\u0022/\u003E or \u003Cparamref name=\u0022requiredBadDescription\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003CThing\u003E\u003E AnonymousBodyAsync(string name, BinaryData requiredUnion, ThingRequiredLiteralString requiredLiteralString, ThingRequiredLiteralInt requiredLiteralInt, ThingRequiredLiteralFloat requiredLiteralFloat, bool requiredLiteralBool, string requiredBadDescription, IEnumerable\u003Cint\u003E requiredNullableList, ThingOptionalLiteralString? optionalLiteralString = default, ThingOptionalLiteralInt? optionalLiteralInt = default, ThingOptionalLiteralFloat? optionalLiteralFloat = default, bool? optionalLiteralBool = default, IEnumerable\u003Cint\u003E optionalNullableList = default)\n        {\n            Argument.AssertNotNull(name, nameof(name));\n            Argument.AssertNotNull(requiredUnion, nameof(requiredUnion));\n            Argument.AssertNotNull(requiredBadDescription, nameof(requiredBadDescription));\n\n            Thing spreadModel = new Thing(\n                name,\n                requiredUnion,\n                requiredLiteralString,\n                requiredLiteralInt,\n                requiredLiteralFloat,\n                requiredLiteralBool,\n                optionalLiteralString,\n                optionalLiteralInt,\n                optionalLiteralFloat,\n                optionalLiteralBool,\n                requiredBadDescription,\n                (optionalNullableList?.ToList() as IList\u003Cint\u003E ?? new ChangeTrackingList\u003Cint\u003E()),\n                (requiredNullableList?.ToList() as IList\u003Cint\u003E ?? new ChangeTrackingList\u003Cint\u003E()),\n                null);\n            ClientResult result = await this.AnonymousBodyAsync(spreadModel, null).ConfigureAwait(false);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Model can have its friendly name\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult FriendlyModel(BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateFriendlyModelRequest(content, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Model can have its friendly name\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E FriendlyModelAsync(BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateFriendlyModelRequest(content, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Model can have its friendly name. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the NotFriend. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult\u003CFriend\u003E FriendlyModel(string name)\n        {\n            Argument.AssertNotNull(name, nameof(name));\n\n            Friend spreadModel = new Friend(name, null);\n            ClientResult result = this.FriendlyModel(spreadModel, null);\n            return ClientResult.FromValue(((Friend)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Model can have its friendly name. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the NotFriend. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003CFriend\u003E\u003E FriendlyModelAsync(string name)\n        {\n            Argument.AssertNotNull(name, nameof(name));\n\n            Friend spreadModel = new Friend(name, null);\n            ClientResult result = await this.FriendlyModelAsync(spreadModel, null).ConfigureAwait(false);\n            return ClientResult.FromValue(((Friend)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] addTimeHeader\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult AddTimeHeader(RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateAddTimeHeaderRequest(options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] addTimeHeader\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E AddTimeHeaderAsync(RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateAddTimeHeaderRequest(options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E addTimeHeader. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult AddTimeHeader()\n        {\n            return this.AddTimeHeader(null);\n        }\n\n        /// \u003Csummary\u003E addTimeHeader. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003E AddTimeHeaderAsync()\n        {\n            return await this.AddTimeHeaderAsync(null).ConfigureAwait(false);\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Model can have its projected name\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult ProjectedNameModel(BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateProjectedNameModelRequest(content, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Model can have its projected name\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E ProjectedNameModelAsync(BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateProjectedNameModelRequest(content, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Model can have its projected name. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the ModelWithProjectedName. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult\u003CProjectedModel\u003E ProjectedNameModel(string name)\n        {\n            Argument.AssertNotNull(name, nameof(name));\n\n            ProjectedModel spreadModel = new ProjectedModel(name, null);\n            ClientResult result = this.ProjectedNameModel(spreadModel, null);\n            return ClientResult.FromValue(((ProjectedModel)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E Model can have its projected name. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022name\u0022\u003E name of the ModelWithProjectedName. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022name\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003CProjectedModel\u003E\u003E ProjectedNameModelAsync(string name)\n        {\n            Argument.AssertNotNull(name, nameof(name));\n\n            ProjectedModel spreadModel = new ProjectedModel(name, null);\n            ClientResult result = await this.ProjectedNameModelAsync(spreadModel, null).ConfigureAwait(false);\n            return ClientResult.FromValue(((ProjectedModel)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] return anonymous model\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult ReturnsAnonymousModel(RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateReturnsAnonymousModelRequest(options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] return anonymous model\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E ReturnsAnonymousModelAsync(RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateReturnsAnonymousModelRequest(options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E return anonymous model. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult\u003CReturnsAnonymousModelResponse\u003E ReturnsAnonymousModel()\n        {\n            ClientResult result = this.ReturnsAnonymousModel(null);\n            return ClientResult.FromValue(((ReturnsAnonymousModelResponse)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E return anonymous model. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003CReturnsAnonymousModelResponse\u003E\u003E ReturnsAnonymousModelAsync()\n        {\n            ClientResult result = await this.ReturnsAnonymousModelAsync(null).ConfigureAwait(false);\n            return ClientResult.FromValue(((ReturnsAnonymousModelResponse)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] get extensible enum\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022accept\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022accept\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult GetUnknownValue(string accept, RequestOptions options)\n        {\n            Argument.AssertNotNull(accept, nameof(accept));\n\n            using PipelineMessage message = this.CreateGetUnknownValueRequest(accept, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] get extensible enum\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022accept\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022accept\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E GetUnknownValueAsync(string accept, RequestOptions options)\n        {\n            Argument.AssertNotNull(accept, nameof(accept));\n\n            using PipelineMessage message = this.CreateGetUnknownValueRequest(accept, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E get extensible enum. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022accept\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022accept\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult\u003Cstring\u003E GetUnknownValue(string accept)\n        {\n            Argument.AssertNotNull(accept, nameof(accept));\n\n            ClientResult result = this.GetUnknownValue(accept, null);\n            return ClientResult.FromValue(result.GetRawResponse().Content.ToObjectFromJson\u003Cstring\u003E(), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E get extensible enum. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022accept\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022accept\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003Cstring\u003E\u003E GetUnknownValueAsync(string accept)\n        {\n            Argument.AssertNotNull(accept, nameof(accept));\n\n            ClientResult result = await this.GetUnknownValueAsync(accept, null).ConfigureAwait(false);\n            return ClientResult.FromValue(result.GetRawResponse().Content.ToObjectFromJson\u003Cstring\u003E(), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] When set protocol false and convenient true, then the protocol method should be internal\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult InternalProtocol(BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateInternalProtocolRequest(content, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] When set protocol false and convenient true, then the protocol method should be internal\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022content\u0022\u003E The content to send as the body of the request. \u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022content\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E InternalProtocolAsync(BinaryContent content, RequestOptions options)\n        {\n            Argument.AssertNotNull(content, nameof(content));\n\n            using PipelineMessage message = this.CreateInternalProtocolRequest(content, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E When set protocol false and convenient true, then the protocol method should be internal. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022body\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022body\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult\u003CThing\u003E InternalProtocol(Thing body)\n        {\n            Argument.AssertNotNull(body, nameof(body));\n\n            ClientResult result = this.InternalProtocol(body, null);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E When set protocol false and convenient true, then the protocol method should be internal. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022body\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022body\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003CThing\u003E\u003E InternalProtocolAsync(Thing body)\n        {\n            Argument.AssertNotNull(body, nameof(body));\n\n            ClientResult result = await this.InternalProtocolAsync(body, null).ConfigureAwait(false);\n            return ClientResult.FromValue(((Thing)result), result.GetRawResponse());\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] When set protocol false and convenient true, the convenient method should be generated even it has the same signature as protocol one\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult StillConvenient(RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateStillConvenientRequest(options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] When set protocol false and convenient true, the convenient method should be generated even it has the same signature as protocol one\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E StillConvenientAsync(RequestOptions options)\n        {\n            using PipelineMessage message = this.CreateStillConvenientRequest(options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E When set protocol false and convenient true, the convenient method should be generated even it has the same signature as protocol one. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult StillConvenient()\n        {\n            return this.StillConvenient(null);\n        }\n\n        /// \u003Csummary\u003E When set protocol false and convenient true, the convenient method should be generated even it has the same signature as protocol one. \u003C/summary\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003E StillConvenientAsync()\n        {\n            return await this.StillConvenientAsync(null).ConfigureAwait(false);\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] head as boolean.\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022id\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022id\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult HeadAsBoolean(string id, RequestOptions options)\n        {\n            Argument.AssertNotNull(id, nameof(id));\n\n            using PipelineMessage message = this.CreateHeadAsBooleanRequest(id, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] head as boolean.\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022id\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022id\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E HeadAsBooleanAsync(string id, RequestOptions options)\n        {\n            Argument.AssertNotNull(id, nameof(id));\n\n            using PipelineMessage message = this.CreateHeadAsBooleanRequest(id, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E head as boolean. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022id\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022id\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult HeadAsBoolean(string id)\n        {\n            Argument.AssertNotNull(id, nameof(id));\n\n            return this.HeadAsBoolean(id, null);\n        }\n\n        /// \u003Csummary\u003E head as boolean. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022id\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022id\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003E HeadAsBooleanAsync(string id)\n        {\n            Argument.AssertNotNull(id, nameof(id));\n\n            return await this.HeadAsBooleanAsync(id, null).ConfigureAwait(false);\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi again\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p1\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual ClientResult WithApiVersion(string p1, RequestOptions options)\n        {\n            Argument.AssertNotNull(p1, nameof(p1));\n\n            using PipelineMessage message = this.CreateWithApiVersionRequest(p1, options);\n            return ClientResult.FromResponse(Pipeline.ProcessMessage(message, options));\n        }\n\n        /// \u003Csummary\u003E\n        /// [Protocol Method] Return hi again\n        /// \u003Clist type=\u0022bullet\u0022\u003E\n        /// \u003Citem\u003E\n        /// \u003Cdescription\u003E This \u003Csee href=\u0022https://aka.ms/azsdk/net/protocol-methods\u0022\u003Eprotocol method\u003C/see\u003E allows explicit creation of the request and processing of the response for advanced scenarios. \u003C/description\u003E\n        /// \u003C/item\u003E\n        /// \u003C/list\u003E\n        /// \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cparam name=\u0022options\u0022\u003E The request options, which can override default behaviors of the client pipeline on a per-call basis. \u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p1\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        /// \u003Creturns\u003E The response returned from the service. \u003C/returns\u003E\n        public virtual async Task\u003CClientResult\u003E WithApiVersionAsync(string p1, RequestOptions options)\n        {\n            Argument.AssertNotNull(p1, nameof(p1));\n\n            using PipelineMessage message = this.CreateWithApiVersionRequest(p1, options);\n            return ClientResult.FromResponse(await Pipeline.ProcessMessageAsync(message, options).ConfigureAwait(false));\n        }\n\n        /// \u003Csummary\u003E Return hi again. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p1\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual ClientResult WithApiVersion(string p1)\n        {\n            Argument.AssertNotNull(p1, nameof(p1));\n\n            return this.WithApiVersion(p1, null);\n        }\n\n        /// \u003Csummary\u003E Return hi again. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022p1\u0022\u003E\u003C/param\u003E\n        /// \u003Cexception cref=\u0022ArgumentNullException\u0022\u003E \u003Cparamref name=\u0022p1\u0022/\u003E is null. \u003C/exception\u003E\n        /// \u003Cexception cref=\u0022ClientResultException\u0022\u003E Service returned a non-success status code. \u003C/exception\u003E\n        public virtual async Task\u003CClientResult\u003E WithApiVersionAsync(string p1)\n        {\n            Argument.AssertNotNull(p1, nameof(p1));\n\n            return await this.WithApiVersionAsync(p1, null).ConfigureAwait(false);\n        }\n    }\n}\n"
          }
        },
        {
          "name": "UnbrandedTypeSpecClient.RestClient.cs",
          "typeDeclaration": {
            "name": "UnbrandedTypeSpecClient",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel;\nusing System.ClientModel.Primitives;\n\nnamespace UnbrandedTypeSpec\n{\n    /// \u003Csummary\u003E\u003C/summary\u003E\n    public partial class UnbrandedTypeSpecClient\n    {\n        private static PipelineMessageClassifier _pipelineMessageClassifier200;\n        private static PipelineMessageClassifier _pipelineMessageClassifier201;\n        private static PipelineMessageClassifier _pipelineMessageClassifier204;\n        private static Classifier2xxAnd4xx _pipelineMessageClassifier2xxAnd4xx;\n\n        private static PipelineMessageClassifier PipelineMessageClassifier200 =\u003E _pipelineMessageClassifier200 = PipelineMessageClassifier.Create(stackalloc ushort[] { 200 });\n\n        private static PipelineMessageClassifier PipelineMessageClassifier201 =\u003E _pipelineMessageClassifier201 = PipelineMessageClassifier.Create(stackalloc ushort[] { 201 });\n\n        private static PipelineMessageClassifier PipelineMessageClassifier204 =\u003E _pipelineMessageClassifier204 = PipelineMessageClassifier.Create(stackalloc ushort[] { 204 });\n\n        private static Classifier2xxAnd4xx PipelineMessageClassifier2xxAnd4xx =\u003E _pipelineMessageClassifier2xxAnd4xx ??= new Classifier2xxAnd4xx();\n\n        internal PipelineMessage CreateSayHiRequest(string headParameter, string queryParameter, string optionalQuery, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/hello\u0022, false);\n            uri.AppendQuery(\u0022queryParameter\u0022, queryParameter, true);\n            if ((optionalQuery != null))\n            {\n                uri.AppendQuery(\u0022optionalQuery\u0022, optionalQuery, true);\n            }\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022head-parameter\u0022, headParameter);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateHelloAgainRequest(string p2, string p1, BinaryContent content, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/againHi/\u0022, false);\n            uri.AppendPath(p2, true);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022p1\u0022, p1);\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022text/plain\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateNoContentTypeRequest(string p2, string p1, BinaryContent content, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/noContentType/\u0022, false);\n            uri.AppendPath(p2, true);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022p1\u0022, p1);\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateHelloDemo2Request(RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/demoHi\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateCreateLiteralRequest(BinaryContent content, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022POST\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/literal\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateHelloLiteralRequest(RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/helloLiteral/\u0022, false);\n            uri.AppendPath(123.ToString(), true);\n            uri.AppendQuery(\u0022p3\u0022, TypeFormatters.ConvertToString(true, null), true);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022p1\u0022, \u0022test\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateTopActionRequest(DateTimeOffset action, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/top/\u0022, false);\n            uri.AppendPath(action.ToString(\u0022O\u0022), true);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateTopAction2Request(RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/top2\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreatePatchActionRequest(BinaryContent content, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022PATCH\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/patch\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateAnonymousBodyRequest(BinaryContent content, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022POST\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/anonymousBody\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateFriendlyModelRequest(BinaryContent content, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022POST\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/friendlyName\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateAddTimeHeaderRequest(RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier204;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Repeatability-First-Sent\u0022, TypeFormatters.ConvertToString(DateTimeOffset.Now, \u0022R\u0022));\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateProjectedNameModelRequest(BinaryContent content, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022POST\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/projectedName\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateReturnsAnonymousModelRequest(RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022POST\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/returnsAnonymousModel\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateGetUnknownValueRequest(string accept, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/unknown-value\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Accept\u0022, accept);\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateInternalProtocolRequest(BinaryContent content, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier200;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022POST\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/internalProtocol\u0022, false);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022Content-Type\u0022, \u0022application/json\u0022);\n            request.Headers.Set(\u0022Accept\u0022, \u0022application/json\u0022);\n            request.Content = content;\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateStillConvenientRequest(RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier204;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/stillConvenient\u0022, false);\n            request.Uri = uri.ToUri();\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateHeadAsBooleanRequest(string id, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier2xxAnd4xx;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022HEAD\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/headAsBoolean/\u0022, false);\n            uri.AppendPath(id, true);\n            request.Uri = uri.ToUri();\n            message.Apply(options);\n            return message;\n        }\n\n        internal PipelineMessage CreateWithApiVersionRequest(string p1, RequestOptions options)\n        {\n            PipelineMessage message = Pipeline.CreateMessage();\n            message.ResponseClassifier = PipelineMessageClassifier204;\n            PipelineRequest request = message.Request;\n            request.Method = \u0022GET\u0022;\n            ClientUriBuilder uri = new ClientUriBuilder();\n            uri.Reset(_endpoint);\n            uri.AppendPath(\u0022/WithApiVersion\u0022, false);\n            uri.AppendQuery(\u0022apiVersion\u0022, _apiVersion, true);\n            request.Uri = uri.ToUri();\n            request.Headers.Set(\u0022p1\u0022, p1);\n            message.Apply(options);\n            return message;\n        }\n\n        private class Classifier2xxAnd4xx : PipelineMessageClassifier\n        {\n            public override bool TryClassify(PipelineMessage message, out bool isError)\n            {\n                isError = false;\n                if ((message.Response == null))\n                {\n                    return false;\n                }\n                isError = message.Response.Status switch\n                {\n                    ((\u003E= 200) and (\u003C 300)) =\u003E false,\n                    ((\u003E= 400) and (\u003C 500)) =\u003E false,\n                    _ =\u003E true\n                };\n                return true;\n            }\n\n            public override bool TryClassify(PipelineMessage message, Exception exception, out bool isRetryable)\n            {\n                isRetryable = false;\n                return false;\n            }\n        }\n    }\n}\n"
          }
        },
        {
          "name": "UnbrandedTypeSpecClientOptions.cs",
          "typeDeclaration": {
            "name": "UnbrandedTypeSpecClientOptions",
            "content": "// \u003Cauto-generated/\u003E\n\n#nullable disable\n\nusing System;\nusing System.ClientModel.Primitives;\n\nnamespace UnbrandedTypeSpec\n{\n    /// \u003Csummary\u003E Client options for \u003Csee cref=\u0022UnbrandedTypeSpecClient\u0022/\u003E. \u003C/summary\u003E\n    public partial class UnbrandedTypeSpecClientOptions : ClientPipelineOptions\n    {\n        private const ServiceVersion LatestVersion = ServiceVersion.V2024_08_16_Preview;\n\n        /// \u003Csummary\u003E Initializes a new instance of UnbrandedTypeSpecClientOptions. \u003C/summary\u003E\n        /// \u003Cparam name=\u0022version\u0022\u003E The service version. \u003C/param\u003E\n        public UnbrandedTypeSpecClientOptions(ServiceVersion version = LatestVersion)\n        {\n            Version = version switch\n            {\n                ServiceVersion.V2024_07_16_Preview =\u003E \u00222024-07-16-preview\u0022,\n                ServiceVersion.V2024_08_16_Preview =\u003E \u00222024-08-16-preview\u0022,\n                _ =\u003E throw new NotSupportedException()\n            };\n        }\n\n        internal string Version { get; }\n\n        /// \u003Csummary\u003E The version of the service to use. \u003C/summary\u003E\n        public enum ServiceVersion\n        {\n            /// \u003Csummary\u003E V2024_07_16_Preview. \u003C/summary\u003E\n            V2024_07_16_Preview = 1,\n            /// \u003Csummary\u003E V2024_08_16_Preview. \u003C/summary\u003E\n            V2024_08_16_Preview = 2\n        }\n    }\n}\n"
          }
        }
      ]
    }
  ]
}